/*
 * John Berg @ netbasenext.nl
 *
 * STM32F030
 *
 * autogenerated on 17.01.2020 21:16
 *
 */

#include <stdint.h>
#include <stddef.h>

typedef volatile uint32_t regrw;

template<size_t addr>
struct Reg
{
    static constexpr void write(size_t val)
    {
        *(reinterpret_cast<volatile size_t*>(addr)) = val;
    }

    static constexpr size_t read()
    {
        return *(reinterpret_cast<volatile size_t*>(addr));
    }
};

template<size_t addr, unsigned pos, unsigned size>
class Property
{
private:
    static constexpr Reg reg = Reg<addr>();
    static constexpr size_t mask =  ((1 << size) - 1);
    static constexpr size_t posmask =  mask << pos;

public:
    Property() = default;
    
    Property& operator=(int x) { reg.write((reg.read() & ~posmask) | (x & mask) << pos); return *this; }
    operator int() const { return (reg.read() >> pos) & mask; }
};

template<typename Enum>
constexpr size_t operator |(Enum leftval, Enum rightval ) 
{
    return (1 << static_cast<size_t>(leftval)) | (1 << static_cast<size_t>(rightval));
}

template<typename Enum>
class reg32bit
{
public:
    constexpr reg32bit & operator =  (Enum e) { raw = (1 << static_cast<size_t>(e)); return *this;}
    constexpr reg32bit & operator =  (uint32_t i) { raw = i; return *this;}

    constexpr reg32bit & operator |= (Enum e) { raw |= 1 << static_cast<size_t>(e); return *this; }
    constexpr reg32bit & operator &= (Enum e) { raw &= 1 << static_cast<size_t>(e); return *this; }  
    constexpr reg32bit & operator ^= (Enum e) { raw ^= 1 << static_cast<size_t>(e); return *this; }

private:
    regrw raw;
};


/*
    General-purpose I/Os
*/
struct GPIO
{
    regrw MODER;                                   // GPIO port mode register
    regrw OTYPER;                                  // GPIO port output type register
    regrw OSPEEDR;                                 // GPIO port output speed register
    regrw PUPDR;                                   // GPIO port pull-up/pull-down register
    regrw IDR;                                     // GPIO port input data register
    regrw ODR;                                     // GPIO port output data register
    regrw BSRR;                                    // GPIO port bit set/reset register
    regrw LCKR;                                    // GPIO port configuration lock register
    regrw AFRL;                                    // GPIO alternate function low register
    regrw AFRH;                                    // GPIO alternate function high register
    regrw BRR;                                     // Port bit reset register
};

struct GPIOA : public GPIO
{
    void *operator new(size_t) {return reinterpret_cast<void *>(0X48000000);}
};

struct GPIOB : public GPIO
{
    void *operator new(size_t) {return reinterpret_cast<void *>(0X48000400);}
};

struct GPIOC : public GPIO
{
    void *operator new(size_t) {return reinterpret_cast<void *>(0X48000800);}
};

struct GPIOD : public GPIO
{
    void *operator new(size_t) {return reinterpret_cast<void *>(0X48000C00);}
};

struct GPIOF : public GPIO
{
    void *operator new(size_t) {return reinterpret_cast<void *>(0X48001400);}
};


enum class ADC_ISR
{
    ADRDY,                     // ADC ready
    EOSMP,                     // End of sampling flag
    EOC,                       // End of conversion flag
    EOS,                       // End of sequence flag
    OVR,                       // ADC overrun
    AWD = 7,                   // Analog watchdog flag
};

/*
    interrupt and status register @ 0X40012400 + 0X00
*/
struct adc_isr : public reg32bit<ADC_ISR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012400 + 0X00, 0, 1> ADRDY;                // ADC ready
    Property<0X40012400 + 0X00, 1, 1> EOSMP;                // End of sampling flag
    Property<0X40012400 + 0X00, 2, 1> EOC;                  // End of conversion flag
    Property<0X40012400 + 0X00, 3, 1> EOS;                  // End of sequence flag
    Property<0X40012400 + 0X00, 4, 1> OVR;                  // ADC overrun
    Property<0X40012400 + 0X00, 7, 1> AWD;                  // Analog watchdog flag
};


enum class ADC_IER
{
    ADRDYIE,                   // ADC ready interrupt enable
    EOSMPIE,                   // End of sampling flag interrupt enable
    EOCIE,                     // End of conversion interrupt enable
    EOSIE,                     // End of conversion sequence interrupt enable
    OVRIE,                     // Overrun interrupt enable
    AWDIE = 7,                 // Analog watchdog interrupt enable
};

/*
    interrupt enable register @ 0X40012400 + 0X04
*/
struct adc_ier : public reg32bit<ADC_IER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012400 + 0X04, 0, 1> ADRDYIE;              // ADC ready interrupt enable
    Property<0X40012400 + 0X04, 1, 1> EOSMPIE;              // End of sampling flag interrupt enable
    Property<0X40012400 + 0X04, 2, 1> EOCIE;                // End of conversion interrupt enable
    Property<0X40012400 + 0X04, 3, 1> EOSIE;                // End of conversion sequence interrupt enable
    Property<0X40012400 + 0X04, 4, 1> OVRIE;                // Overrun interrupt enable
    Property<0X40012400 + 0X04, 7, 1> AWDIE;                // Analog watchdog interrupt enable
};


enum class ADC_CR
{
    ADEN,                      // ADC enable command
    ADDIS,                     // ADC disable command
    ADSTART,                   // ADC start conversion command
    ADSTP = 4,                 // ADC stop conversion command
    ADCAL = 31,                // ADC calibration
};

/*
    control register @ 0X40012400 + 0X08
*/
struct adc_cr : public reg32bit<ADC_CR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012400 + 0X08, 0, 1> ADEN;                 // ADC enable command
    Property<0X40012400 + 0X08, 1, 1> ADDIS;                // ADC disable command
    Property<0X40012400 + 0X08, 2, 1> ADSTART;              // ADC start conversion command
    Property<0X40012400 + 0X08, 4, 1> ADSTP;                // ADC stop conversion command
    Property<0X40012400 + 0X08, 31, 1> ADCAL;               // ADC calibration
};


enum class ADC_CFGR1
{
    DMAEN,                     // Direct memory access enable
    DMACFG,                    // Direct memery access configuration
    SCANDIR,                   // Scan sequence direction
    RES,                       // Data resolution
    ALIGN = 5,                 // Data alignment
    EXTSEL,                    // External trigger selection
    EXTEN = 10,                // External trigger enable and polarity selection
    OVRMOD = 12,               // Overrun management mode
    CONT,                      // Single / continuous conversion mode
    AUTDLY,                    // Auto-delayed conversion mode
    AUTOFF,                    // Auto-off mode
    DISCEN,                    // Discontinuous mode
    AWDSGL = 22,               // Enable the watchdog on a single channel or on all channels
    AWDEN,                     // Analog watchdog enable
    AWDCH = 26,                // Analog watchdog channel selection
};

/*
    configuration register 1 @ 0X40012400 + 0X0C
*/
struct adc_cfgr1 : public reg32bit<ADC_CFGR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012400 + 0X0C, 0, 1> DMAEN;                // Direct memory access enable
    Property<0X40012400 + 0X0C, 1, 1> DMACFG;               // Direct memery access configuration
    Property<0X40012400 + 0X0C, 2, 1> SCANDIR;              // Scan sequence direction
    Property<0X40012400 + 0X0C, 3, 2> RES;                  // Data resolution
    Property<0X40012400 + 0X0C, 5, 1> ALIGN;                // Data alignment
    Property<0X40012400 + 0X0C, 6, 3> EXTSEL;               // External trigger selection
    Property<0X40012400 + 0X0C, 10, 2> EXTEN;               // External trigger enable and polarity selection
    Property<0X40012400 + 0X0C, 12, 1> OVRMOD;              // Overrun management mode
    Property<0X40012400 + 0X0C, 13, 1> CONT;                // Single / continuous conversion mode
    Property<0X40012400 + 0X0C, 14, 1> AUTDLY;              // Auto-delayed conversion mode
    Property<0X40012400 + 0X0C, 15, 1> AUTOFF;              // Auto-off mode
    Property<0X40012400 + 0X0C, 16, 1> DISCEN;              // Discontinuous mode
    Property<0X40012400 + 0X0C, 22, 1> AWDSGL;              // Enable the watchdog on a single channel or on all channels
    Property<0X40012400 + 0X0C, 23, 1> AWDEN;               // Analog watchdog enable
    Property<0X40012400 + 0X0C, 26, 5> AWDCH;               // Analog watchdog channel selection
};


enum class ADC_CFGR2
{
    JITOFF_D2 = 30,            // JITOFF_D2
    JITOFF_D4,                 // JITOFF_D4
};

/*
    configuration register 2 @ 0X40012400 + 0X10
*/
struct adc_cfgr2 : public reg32bit<ADC_CFGR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012400 + 0X10, 30, 1> JITOFF_D2;           // JITOFF_D2
    Property<0X40012400 + 0X10, 31, 1> JITOFF_D4;           // JITOFF_D4
};


enum class ADC_TR
{
    LT,                        // Analog watchdog lower threshold
    HT = 16,                   // Analog watchdog higher threshold
};

/*
    watchdog threshold register @ 0X40012400 + 0X20
*/
struct adc_tr : public reg32bit<ADC_TR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012400 + 0X20, 0, 12> LT;                  // Analog watchdog lower threshold
    Property<0X40012400 + 0X20, 16, 12> HT;                 // Analog watchdog higher threshold
};


enum class ADC_CHSELR
{
    CHSEL0,                    // Channel-x selection
    CHSEL1,                    // Channel-x selection
    CHSEL2,                    // Channel-x selection
    CHSEL3,                    // Channel-x selection
    CHSEL4,                    // Channel-x selection
    CHSEL5,                    // Channel-x selection
    CHSEL6,                    // Channel-x selection
    CHSEL7,                    // Channel-x selection
    CHSEL8,                    // Channel-x selection
    CHSEL9,                    // Channel-x selection
    CHSEL10,                   // Channel-x selection
    CHSEL11,                   // Channel-x selection
    CHSEL12,                   // Channel-x selection
    CHSEL13,                   // Channel-x selection
    CHSEL14,                   // Channel-x selection
    CHSEL15,                   // Channel-x selection
    CHSEL16,                   // Channel-x selection
    CHSEL17,                   // Channel-x selection
    CHSEL18,                   // Channel-x selection
};

/*
    channel selection register @ 0X40012400 + 0X28
*/
struct adc_chselr : public reg32bit<ADC_CHSELR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012400 + 0X28, 0, 1> CHSEL0;               // Channel-x selection
    Property<0X40012400 + 0X28, 1, 1> CHSEL1;               // Channel-x selection
    Property<0X40012400 + 0X28, 2, 1> CHSEL2;               // Channel-x selection
    Property<0X40012400 + 0X28, 3, 1> CHSEL3;               // Channel-x selection
    Property<0X40012400 + 0X28, 4, 1> CHSEL4;               // Channel-x selection
    Property<0X40012400 + 0X28, 5, 1> CHSEL5;               // Channel-x selection
    Property<0X40012400 + 0X28, 6, 1> CHSEL6;               // Channel-x selection
    Property<0X40012400 + 0X28, 7, 1> CHSEL7;               // Channel-x selection
    Property<0X40012400 + 0X28, 8, 1> CHSEL8;               // Channel-x selection
    Property<0X40012400 + 0X28, 9, 1> CHSEL9;               // Channel-x selection
    Property<0X40012400 + 0X28, 10, 1> CHSEL10;             // Channel-x selection
    Property<0X40012400 + 0X28, 11, 1> CHSEL11;             // Channel-x selection
    Property<0X40012400 + 0X28, 12, 1> CHSEL12;             // Channel-x selection
    Property<0X40012400 + 0X28, 13, 1> CHSEL13;             // Channel-x selection
    Property<0X40012400 + 0X28, 14, 1> CHSEL14;             // Channel-x selection
    Property<0X40012400 + 0X28, 15, 1> CHSEL15;             // Channel-x selection
    Property<0X40012400 + 0X28, 16, 1> CHSEL16;             // Channel-x selection
    Property<0X40012400 + 0X28, 17, 1> CHSEL17;             // Channel-x selection
    Property<0X40012400 + 0X28, 18, 1> CHSEL18;             // Channel-x selection
};


enum class ADC_CCR
{
    VREFEN = 22,               // Temperature sensor and VREFINT enable
    TSEN,                      // Temperature sensor enable
    VBATEN,                    // VBAT enable
};

/*
    common configuration register @ 0X40012400 + 0X0308
*/
struct adc_ccr : public reg32bit<ADC_CCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012400 + 0X0308, 22, 1> VREFEN;            // Temperature sensor and VREFINT enable
    Property<0X40012400 + 0X0308, 23, 1> TSEN;              // Temperature sensor enable
    Property<0X40012400 + 0X0308, 24, 1> VBATEN;            // VBAT enable
};


/*
    Analog-to-digital converter @ 0X40012400
*/
struct ADC
{
    adc_isr ISR;               // interrupt and status register
    adc_ier IER;               // interrupt enable register
    adc_cr CR;                 // control register
    adc_cfgr1 CFGR1;           // configuration register 1
    adc_cfgr2 CFGR2;           // configuration register 2
    regrw SMPR;                // sampling time register
    adc_tr TR;                 // watchdog threshold register
    adc_chselr CHSELR;         // channel selection register
    regrw DR;                  // data register
    adc_ccr CCR;               // common configuration register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40012400);}
};


enum class CRC_CR
{
    RESET,                     // reset bit
    REV_IN = 5,                // Reverse input data
    REV_OUT = 7,               // Reverse output data
};

/*
    Control register @ 0X40023000 + 0X08
*/
struct crc_cr : public reg32bit<CRC_CR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40023000 + 0X08, 0, 1> RESET;                // reset bit
    Property<0X40023000 + 0X08, 5, 2> REV_IN;               // Reverse input data
    Property<0X40023000 + 0X08, 7, 1> REV_OUT;              // Reverse output data
};


/*
    cyclic redundancy check calculation unit @ 0X40023000
*/
struct CRC
{
    regrw DR;                  // Data register
    regrw IDR;                 // Independent data register
    crc_cr CR;                 // Control register
    regrw INIT;                // Initial CRC value

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40023000);}
};


enum class DBGMCU_IDCODE
{
    DEV_ID,                    // Device Identifier
    DIV_ID = 12,               // Division Identifier
    REV_ID = 16,               // Revision Identifier
};

/*
    MCU Device ID Code Register @ 0X40015800 + 0X00
*/
struct dbgmcu_idcode : public reg32bit<DBGMCU_IDCODE>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40015800 + 0X00, 0, 12> DEV_ID;              // Device Identifier
    Property<0X40015800 + 0X00, 12, 4> DIV_ID;              // Division Identifier
    Property<0X40015800 + 0X00, 16, 16> REV_ID;             // Revision Identifier
};


enum class DBGMCU_CR
{
    DBG_STOP = 1,              // Debug Stop Mode
    DBG_STANDBY,               // Debug Standby Mode
};

/*
    Debug MCU Configuration Register @ 0X40015800 + 0X04
*/
struct dbgmcu_cr : public reg32bit<DBGMCU_CR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40015800 + 0X04, 1, 1> DBG_STOP;             // Debug Stop Mode
    Property<0X40015800 + 0X04, 2, 1> DBG_STANDBY;          // Debug Standby Mode
};


enum class DBGMCU_APBLFZ
{
    DBG_TIMER2_STOP,           // Debug Timer 2 stopped when Core is halted
    DBG_TIMER3_STOP,           // Debug Timer 3 stopped when Core is halted
    DBG_TIMER6_STOP = 4,       // Debug Timer 6 stopped when Core is halted
    DBG_TIMER14_STOP = 8,      // Debug Timer 14 stopped when Core is halted
    DBG_RTC_STOP = 10,         // Debug RTC stopped when Core is halted
    DBG_WWDG_STOP,             // Debug Window Wachdog stopped when Core is halted
    DBG_IWDG_STOP,             // Debug Independent Wachdog stopped when Core is halted
    I2C1_SMBUS_TIMEOUT = 21,   // SMBUS timeout mode stopped when Core is halted
};

/*
    APB Low Freeze Register @ 0X40015800 + 0X08
*/
struct dbgmcu_apblfz : public reg32bit<DBGMCU_APBLFZ>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40015800 + 0X08, 0, 1> DBG_TIMER2_STOP;      // Debug Timer 2 stopped when Core is halted
    Property<0X40015800 + 0X08, 1, 1> DBG_TIMER3_STOP;      // Debug Timer 3 stopped when Core is halted
    Property<0X40015800 + 0X08, 4, 1> DBG_TIMER6_STOP;      // Debug Timer 6 stopped when Core is halted
    Property<0X40015800 + 0X08, 8, 1> DBG_TIMER14_STOP;     // Debug Timer 14 stopped when Core is halted
    Property<0X40015800 + 0X08, 10, 1> DBG_RTC_STOP;        // Debug RTC stopped when Core is halted
    Property<0X40015800 + 0X08, 11, 1> DBG_WWDG_STOP;       // Debug Window Wachdog stopped when Core is halted
    Property<0X40015800 + 0X08, 12, 1> DBG_IWDG_STOP;       // Debug Independent Wachdog stopped when Core is halted
    Property<0X40015800 + 0X08, 21, 1> I2C1_SMBUS_TIMEOUT;  // SMBUS timeout mode stopped when Core is halted
};


enum class DBGMCU_APBHFZ
{
    DBG_TIMER1_STOP = 11,      // Debug Timer 1 stopped when Core is halted
    DBG_TIMER15_STO = 16,      // Debug Timer 15 stopped when Core is halted
    DBG_TIMER16_STO,           // Debug Timer 16 stopped when Core is halted
    DBG_TIMER17_STO,           // Debug Timer 17 stopped when Core is halted
};

/*
    APB High Freeze Register @ 0X40015800 + 0X0C
*/
struct dbgmcu_apbhfz : public reg32bit<DBGMCU_APBHFZ>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40015800 + 0X0C, 11, 1> DBG_TIMER1_STOP;     // Debug Timer 1 stopped when Core is halted
    Property<0X40015800 + 0X0C, 16, 1> DBG_TIMER15_STO;     // Debug Timer 15 stopped when Core is halted
    Property<0X40015800 + 0X0C, 17, 1> DBG_TIMER16_STO;     // Debug Timer 16 stopped when Core is halted
    Property<0X40015800 + 0X0C, 18, 1> DBG_TIMER17_STO;     // Debug Timer 17 stopped when Core is halted
};


/*
    Debug support @ 0X40015800
*/
struct DBGMCU
{
    dbgmcu_idcode IDCODE;      // MCU Device ID Code Register
    dbgmcu_cr CR;              // Debug MCU Configuration Register
    dbgmcu_apblfz APBLFZ;      // APB Low Freeze Register
    dbgmcu_apbhfz APBHFZ;      // APB High Freeze Register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40015800);}
};


enum class DMA_ISR
{
    GIF1,                      // Channel 1 Global interrupt flag
    TCIF1,                     // Channel 1 Transfer Complete flag
    HTIF1,                     // Channel 1 Half Transfer Complete flag
    TEIF1,                     // Channel 1 Transfer Error flag
    GIF2,                      // Channel 2 Global interrupt flag
    TCIF2,                     // Channel 2 Transfer Complete flag
    HTIF2,                     // Channel 2 Half Transfer Complete flag
    TEIF2,                     // Channel 2 Transfer Error flag
    GIF3,                      // Channel 3 Global interrupt flag
    TCIF3,                     // Channel 3 Transfer Complete flag
    HTIF3,                     // Channel 3 Half Transfer Complete flag
    TEIF3,                     // Channel 3 Transfer Error flag
    GIF4,                      // Channel 4 Global interrupt flag
    TCIF4,                     // Channel 4 Transfer Complete flag
    HTIF4,                     // Channel 4 Half Transfer Complete flag
    TEIF4,                     // Channel 4 Transfer Error flag
    GIF5,                      // Channel 5 Global interrupt flag
    TCIF5,                     // Channel 5 Transfer Complete flag
    HTIF5,                     // Channel 5 Half Transfer Complete flag
    TEIF5,                     // Channel 5 Transfer Error flag
    GIF6,                      // Channel 6 Global interrupt flag
    TCIF6,                     // Channel 6 Transfer Complete flag
    HTIF6,                     // Channel 6 Half Transfer Complete flag
    TEIF6,                     // Channel 6 Transfer Error flag
    GIF7,                      // Channel 7 Global interrupt flag
    TCIF7,                     // Channel 7 Transfer Complete flag
    HTIF7,                     // Channel 7 Half Transfer Complete flag
    TEIF7,                     // Channel 7 Transfer Error flag
};

/*
    DMA interrupt status register (DMA_ISR) @ 0X40020000 + 0X00
*/
struct dma_isr : public reg32bit<DMA_ISR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X00, 0, 1> GIF1;                 // Channel 1 Global interrupt flag
    Property<0X40020000 + 0X00, 1, 1> TCIF1;                // Channel 1 Transfer Complete flag
    Property<0X40020000 + 0X00, 2, 1> HTIF1;                // Channel 1 Half Transfer Complete flag
    Property<0X40020000 + 0X00, 3, 1> TEIF1;                // Channel 1 Transfer Error flag
    Property<0X40020000 + 0X00, 4, 1> GIF2;                 // Channel 2 Global interrupt flag
    Property<0X40020000 + 0X00, 5, 1> TCIF2;                // Channel 2 Transfer Complete flag
    Property<0X40020000 + 0X00, 6, 1> HTIF2;                // Channel 2 Half Transfer Complete flag
    Property<0X40020000 + 0X00, 7, 1> TEIF2;                // Channel 2 Transfer Error flag
    Property<0X40020000 + 0X00, 8, 1> GIF3;                 // Channel 3 Global interrupt flag
    Property<0X40020000 + 0X00, 9, 1> TCIF3;                // Channel 3 Transfer Complete flag
    Property<0X40020000 + 0X00, 10, 1> HTIF3;               // Channel 3 Half Transfer Complete flag
    Property<0X40020000 + 0X00, 11, 1> TEIF3;               // Channel 3 Transfer Error flag
    Property<0X40020000 + 0X00, 12, 1> GIF4;                // Channel 4 Global interrupt flag
    Property<0X40020000 + 0X00, 13, 1> TCIF4;               // Channel 4 Transfer Complete flag
    Property<0X40020000 + 0X00, 14, 1> HTIF4;               // Channel 4 Half Transfer Complete flag
    Property<0X40020000 + 0X00, 15, 1> TEIF4;               // Channel 4 Transfer Error flag
    Property<0X40020000 + 0X00, 16, 1> GIF5;                // Channel 5 Global interrupt flag
    Property<0X40020000 + 0X00, 17, 1> TCIF5;               // Channel 5 Transfer Complete flag
    Property<0X40020000 + 0X00, 18, 1> HTIF5;               // Channel 5 Half Transfer Complete flag
    Property<0X40020000 + 0X00, 19, 1> TEIF5;               // Channel 5 Transfer Error flag
    Property<0X40020000 + 0X00, 20, 1> GIF6;                // Channel 6 Global interrupt flag
    Property<0X40020000 + 0X00, 21, 1> TCIF6;               // Channel 6 Transfer Complete flag
    Property<0X40020000 + 0X00, 22, 1> HTIF6;               // Channel 6 Half Transfer Complete flag
    Property<0X40020000 + 0X00, 23, 1> TEIF6;               // Channel 6 Transfer Error flag
    Property<0X40020000 + 0X00, 24, 1> GIF7;                // Channel 7 Global interrupt flag
    Property<0X40020000 + 0X00, 25, 1> TCIF7;               // Channel 7 Transfer Complete flag
    Property<0X40020000 + 0X00, 26, 1> HTIF7;               // Channel 7 Half Transfer Complete flag
    Property<0X40020000 + 0X00, 27, 1> TEIF7;               // Channel 7 Transfer Error flag
};


enum class DMA_IFCR
{
    CGIF1,                     // Channel 1 Global interrupt clear
    CTCIF1,                    // Channel 1 Transfer Complete clear
    CHTIF1,                    // Channel 1 Half Transfer clear
    CTEIF1,                    // Channel 1 Transfer Error clear
    CGIF2,                     // Channel 2 Global interrupt clear
    CTCIF2,                    // Channel 2 Transfer Complete clear
    CHTIF2,                    // Channel 2 Half Transfer clear
    CTEIF2,                    // Channel 2 Transfer Error clear
    CGIF3,                     // Channel 3 Global interrupt clear
    CTCIF3,                    // Channel 3 Transfer Complete clear
    CHTIF3,                    // Channel 3 Half Transfer clear
    CTEIF3,                    // Channel 3 Transfer Error clear
    CGIF4,                     // Channel 4 Global interrupt clear
    CTCIF4,                    // Channel 4 Transfer Complete clear
    CHTIF4,                    // Channel 4 Half Transfer clear
    CTEIF4,                    // Channel 4 Transfer Error clear
    CGIF5,                     // Channel 5 Global interrupt clear
    CTCIF5,                    // Channel 5 Transfer Complete clear
    CHTIF5,                    // Channel 5 Half Transfer clear
    CTEIF5,                    // Channel 5 Transfer Error clear
    CGIF6,                     // Channel 6 Global interrupt clear
    CTCIF6,                    // Channel 6 Transfer Complete clear
    CHTIF6,                    // Channel 6 Half Transfer clear
    CTEIF6,                    // Channel 6 Transfer Error clear
    CGIF7,                     // Channel 7 Global interrupt clear
    CTCIF7,                    // Channel 7 Transfer Complete clear
    CHTIF7,                    // Channel 7 Half Transfer clear
    CTEIF7,                    // Channel 7 Transfer Error clear
};

/*
    DMA interrupt flag clear register (DMA_IFCR) @ 0X40020000 + 0X04
*/
struct dma_ifcr : public reg32bit<DMA_IFCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X04, 0, 1> CGIF1;                // Channel 1 Global interrupt clear
    Property<0X40020000 + 0X04, 1, 1> CTCIF1;               // Channel 1 Transfer Complete clear
    Property<0X40020000 + 0X04, 2, 1> CHTIF1;               // Channel 1 Half Transfer clear
    Property<0X40020000 + 0X04, 3, 1> CTEIF1;               // Channel 1 Transfer Error clear
    Property<0X40020000 + 0X04, 4, 1> CGIF2;                // Channel 2 Global interrupt clear
    Property<0X40020000 + 0X04, 5, 1> CTCIF2;               // Channel 2 Transfer Complete clear
    Property<0X40020000 + 0X04, 6, 1> CHTIF2;               // Channel 2 Half Transfer clear
    Property<0X40020000 + 0X04, 7, 1> CTEIF2;               // Channel 2 Transfer Error clear
    Property<0X40020000 + 0X04, 8, 1> CGIF3;                // Channel 3 Global interrupt clear
    Property<0X40020000 + 0X04, 9, 1> CTCIF3;               // Channel 3 Transfer Complete clear
    Property<0X40020000 + 0X04, 10, 1> CHTIF3;              // Channel 3 Half Transfer clear
    Property<0X40020000 + 0X04, 11, 1> CTEIF3;              // Channel 3 Transfer Error clear
    Property<0X40020000 + 0X04, 12, 1> CGIF4;               // Channel 4 Global interrupt clear
    Property<0X40020000 + 0X04, 13, 1> CTCIF4;              // Channel 4 Transfer Complete clear
    Property<0X40020000 + 0X04, 14, 1> CHTIF4;              // Channel 4 Half Transfer clear
    Property<0X40020000 + 0X04, 15, 1> CTEIF4;              // Channel 4 Transfer Error clear
    Property<0X40020000 + 0X04, 16, 1> CGIF5;               // Channel 5 Global interrupt clear
    Property<0X40020000 + 0X04, 17, 1> CTCIF5;              // Channel 5 Transfer Complete clear
    Property<0X40020000 + 0X04, 18, 1> CHTIF5;              // Channel 5 Half Transfer clear
    Property<0X40020000 + 0X04, 19, 1> CTEIF5;              // Channel 5 Transfer Error clear
    Property<0X40020000 + 0X04, 20, 1> CGIF6;               // Channel 6 Global interrupt clear
    Property<0X40020000 + 0X04, 21, 1> CTCIF6;              // Channel 6 Transfer Complete clear
    Property<0X40020000 + 0X04, 22, 1> CHTIF6;              // Channel 6 Half Transfer clear
    Property<0X40020000 + 0X04, 23, 1> CTEIF6;              // Channel 6 Transfer Error clear
    Property<0X40020000 + 0X04, 24, 1> CGIF7;               // Channel 7 Global interrupt clear
    Property<0X40020000 + 0X04, 25, 1> CTCIF7;              // Channel 7 Transfer Complete clear
    Property<0X40020000 + 0X04, 26, 1> CHTIF7;              // Channel 7 Half Transfer clear
    Property<0X40020000 + 0X04, 27, 1> CTEIF7;              // Channel 7 Transfer Error clear
};


enum class DMA_CCR1
{
    EN,                        // Channel enable
    TCIE,                      // Transfer complete interrupt enable
    HTIE,                      // Half Transfer interrupt enable
    TEIE,                      // Transfer error interrupt enable
    DIR,                       // Data transfer direction
    CIRC,                      // Circular mode
    PINC,                      // Peripheral increment mode
    MINC,                      // Memory increment mode
    PSIZE,                     // Peripheral size
    MSIZE = 10,                // Memory size
    PL = 12,                   // Channel Priority level
    MEM2MEM = 14,              // Memory to memory mode
};

/*
    DMA channel configuration register (DMA_CCR) @ 0X40020000 + 0X08
*/
struct dma_ccr1 : public reg32bit<DMA_CCR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X08, 0, 1> EN;                   // Channel enable
    Property<0X40020000 + 0X08, 1, 1> TCIE;                 // Transfer complete interrupt enable
    Property<0X40020000 + 0X08, 2, 1> HTIE;                 // Half Transfer interrupt enable
    Property<0X40020000 + 0X08, 3, 1> TEIE;                 // Transfer error interrupt enable
    Property<0X40020000 + 0X08, 4, 1> DIR;                  // Data transfer direction
    Property<0X40020000 + 0X08, 5, 1> CIRC;                 // Circular mode
    Property<0X40020000 + 0X08, 6, 1> PINC;                 // Peripheral increment mode
    Property<0X40020000 + 0X08, 7, 1> MINC;                 // Memory increment mode
    Property<0X40020000 + 0X08, 8, 2> PSIZE;                // Peripheral size
    Property<0X40020000 + 0X08, 10, 2> MSIZE;               // Memory size
    Property<0X40020000 + 0X08, 12, 2> PL;                  // Channel Priority level
    Property<0X40020000 + 0X08, 14, 1> MEM2MEM;             // Memory to memory mode
};


enum class DMA_CCR2
{
    EN,                        // Channel enable
    TCIE,                      // Transfer complete interrupt enable
    HTIE,                      // Half Transfer interrupt enable
    TEIE,                      // Transfer error interrupt enable
    DIR,                       // Data transfer direction
    CIRC,                      // Circular mode
    PINC,                      // Peripheral increment mode
    MINC,                      // Memory increment mode
    PSIZE,                     // Peripheral size
    MSIZE = 10,                // Memory size
    PL = 12,                   // Channel Priority level
    MEM2MEM = 14,              // Memory to memory mode
};

/*
    DMA channel configuration register (DMA_CCR) @ 0X40020000 + 0X1C
*/
struct dma_ccr2 : public reg32bit<DMA_CCR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X1C, 0, 1> EN;                   // Channel enable
    Property<0X40020000 + 0X1C, 1, 1> TCIE;                 // Transfer complete interrupt enable
    Property<0X40020000 + 0X1C, 2, 1> HTIE;                 // Half Transfer interrupt enable
    Property<0X40020000 + 0X1C, 3, 1> TEIE;                 // Transfer error interrupt enable
    Property<0X40020000 + 0X1C, 4, 1> DIR;                  // Data transfer direction
    Property<0X40020000 + 0X1C, 5, 1> CIRC;                 // Circular mode
    Property<0X40020000 + 0X1C, 6, 1> PINC;                 // Peripheral increment mode
    Property<0X40020000 + 0X1C, 7, 1> MINC;                 // Memory increment mode
    Property<0X40020000 + 0X1C, 8, 2> PSIZE;                // Peripheral size
    Property<0X40020000 + 0X1C, 10, 2> MSIZE;               // Memory size
    Property<0X40020000 + 0X1C, 12, 2> PL;                  // Channel Priority level
    Property<0X40020000 + 0X1C, 14, 1> MEM2MEM;             // Memory to memory mode
};


enum class DMA_CCR3
{
    EN,                        // Channel enable
    TCIE,                      // Transfer complete interrupt enable
    HTIE,                      // Half Transfer interrupt enable
    TEIE,                      // Transfer error interrupt enable
    DIR,                       // Data transfer direction
    CIRC,                      // Circular mode
    PINC,                      // Peripheral increment mode
    MINC,                      // Memory increment mode
    PSIZE,                     // Peripheral size
    MSIZE = 10,                // Memory size
    PL = 12,                   // Channel Priority level
    MEM2MEM = 14,              // Memory to memory mode
};

/*
    DMA channel configuration register (DMA_CCR) @ 0X40020000 + 0X30
*/
struct dma_ccr3 : public reg32bit<DMA_CCR3>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X30, 0, 1> EN;                   // Channel enable
    Property<0X40020000 + 0X30, 1, 1> TCIE;                 // Transfer complete interrupt enable
    Property<0X40020000 + 0X30, 2, 1> HTIE;                 // Half Transfer interrupt enable
    Property<0X40020000 + 0X30, 3, 1> TEIE;                 // Transfer error interrupt enable
    Property<0X40020000 + 0X30, 4, 1> DIR;                  // Data transfer direction
    Property<0X40020000 + 0X30, 5, 1> CIRC;                 // Circular mode
    Property<0X40020000 + 0X30, 6, 1> PINC;                 // Peripheral increment mode
    Property<0X40020000 + 0X30, 7, 1> MINC;                 // Memory increment mode
    Property<0X40020000 + 0X30, 8, 2> PSIZE;                // Peripheral size
    Property<0X40020000 + 0X30, 10, 2> MSIZE;               // Memory size
    Property<0X40020000 + 0X30, 12, 2> PL;                  // Channel Priority level
    Property<0X40020000 + 0X30, 14, 1> MEM2MEM;             // Memory to memory mode
};


enum class DMA_CCR4
{
    EN,                        // Channel enable
    TCIE,                      // Transfer complete interrupt enable
    HTIE,                      // Half Transfer interrupt enable
    TEIE,                      // Transfer error interrupt enable
    DIR,                       // Data transfer direction
    CIRC,                      // Circular mode
    PINC,                      // Peripheral increment mode
    MINC,                      // Memory increment mode
    PSIZE,                     // Peripheral size
    MSIZE = 10,                // Memory size
    PL = 12,                   // Channel Priority level
    MEM2MEM = 14,              // Memory to memory mode
};

/*
    DMA channel configuration register (DMA_CCR) @ 0X40020000 + 0X44
*/
struct dma_ccr4 : public reg32bit<DMA_CCR4>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X44, 0, 1> EN;                   // Channel enable
    Property<0X40020000 + 0X44, 1, 1> TCIE;                 // Transfer complete interrupt enable
    Property<0X40020000 + 0X44, 2, 1> HTIE;                 // Half Transfer interrupt enable
    Property<0X40020000 + 0X44, 3, 1> TEIE;                 // Transfer error interrupt enable
    Property<0X40020000 + 0X44, 4, 1> DIR;                  // Data transfer direction
    Property<0X40020000 + 0X44, 5, 1> CIRC;                 // Circular mode
    Property<0X40020000 + 0X44, 6, 1> PINC;                 // Peripheral increment mode
    Property<0X40020000 + 0X44, 7, 1> MINC;                 // Memory increment mode
    Property<0X40020000 + 0X44, 8, 2> PSIZE;                // Peripheral size
    Property<0X40020000 + 0X44, 10, 2> MSIZE;               // Memory size
    Property<0X40020000 + 0X44, 12, 2> PL;                  // Channel Priority level
    Property<0X40020000 + 0X44, 14, 1> MEM2MEM;             // Memory to memory mode
};


enum class DMA_CCR5
{
    EN,                        // Channel enable
    TCIE,                      // Transfer complete interrupt enable
    HTIE,                      // Half Transfer interrupt enable
    TEIE,                      // Transfer error interrupt enable
    DIR,                       // Data transfer direction
    CIRC,                      // Circular mode
    PINC,                      // Peripheral increment mode
    MINC,                      // Memory increment mode
    PSIZE,                     // Peripheral size
    MSIZE = 10,                // Memory size
    PL = 12,                   // Channel Priority level
    MEM2MEM = 14,              // Memory to memory mode
};

/*
    DMA channel configuration register (DMA_CCR) @ 0X40020000 + 0X58
*/
struct dma_ccr5 : public reg32bit<DMA_CCR5>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X58, 0, 1> EN;                   // Channel enable
    Property<0X40020000 + 0X58, 1, 1> TCIE;                 // Transfer complete interrupt enable
    Property<0X40020000 + 0X58, 2, 1> HTIE;                 // Half Transfer interrupt enable
    Property<0X40020000 + 0X58, 3, 1> TEIE;                 // Transfer error interrupt enable
    Property<0X40020000 + 0X58, 4, 1> DIR;                  // Data transfer direction
    Property<0X40020000 + 0X58, 5, 1> CIRC;                 // Circular mode
    Property<0X40020000 + 0X58, 6, 1> PINC;                 // Peripheral increment mode
    Property<0X40020000 + 0X58, 7, 1> MINC;                 // Memory increment mode
    Property<0X40020000 + 0X58, 8, 2> PSIZE;                // Peripheral size
    Property<0X40020000 + 0X58, 10, 2> MSIZE;               // Memory size
    Property<0X40020000 + 0X58, 12, 2> PL;                  // Channel Priority level
    Property<0X40020000 + 0X58, 14, 1> MEM2MEM;             // Memory to memory mode
};


enum class DMA_CCR6
{
    EN,                        // Channel enable
    TCIE,                      // Transfer complete interrupt enable
    HTIE,                      // Half Transfer interrupt enable
    TEIE,                      // Transfer error interrupt enable
    DIR,                       // Data transfer direction
    CIRC,                      // Circular mode
    PINC,                      // Peripheral increment mode
    MINC,                      // Memory increment mode
    PSIZE,                     // Peripheral size
    MSIZE = 10,                // Memory size
    PL = 12,                   // Channel Priority level
    MEM2MEM = 14,              // Memory to memory mode
};

/*
    DMA channel configuration register (DMA_CCR) @ 0X40020000 + 0X6C
*/
struct dma_ccr6 : public reg32bit<DMA_CCR6>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X6C, 0, 1> EN;                   // Channel enable
    Property<0X40020000 + 0X6C, 1, 1> TCIE;                 // Transfer complete interrupt enable
    Property<0X40020000 + 0X6C, 2, 1> HTIE;                 // Half Transfer interrupt enable
    Property<0X40020000 + 0X6C, 3, 1> TEIE;                 // Transfer error interrupt enable
    Property<0X40020000 + 0X6C, 4, 1> DIR;                  // Data transfer direction
    Property<0X40020000 + 0X6C, 5, 1> CIRC;                 // Circular mode
    Property<0X40020000 + 0X6C, 6, 1> PINC;                 // Peripheral increment mode
    Property<0X40020000 + 0X6C, 7, 1> MINC;                 // Memory increment mode
    Property<0X40020000 + 0X6C, 8, 2> PSIZE;                // Peripheral size
    Property<0X40020000 + 0X6C, 10, 2> MSIZE;               // Memory size
    Property<0X40020000 + 0X6C, 12, 2> PL;                  // Channel Priority level
    Property<0X40020000 + 0X6C, 14, 1> MEM2MEM;             // Memory to memory mode
};


enum class DMA_CCR7
{
    EN,                        // Channel enable
    TCIE,                      // Transfer complete interrupt enable
    HTIE,                      // Half Transfer interrupt enable
    TEIE,                      // Transfer error interrupt enable
    DIR,                       // Data transfer direction
    CIRC,                      // Circular mode
    PINC,                      // Peripheral increment mode
    MINC,                      // Memory increment mode
    PSIZE,                     // Peripheral size
    MSIZE = 10,                // Memory size
    PL = 12,                   // Channel Priority level
    MEM2MEM = 14,              // Memory to memory mode
};

/*
    DMA channel configuration register (DMA_CCR) @ 0X40020000 + 0X80
*/
struct dma_ccr7 : public reg32bit<DMA_CCR7>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40020000 + 0X80, 0, 1> EN;                   // Channel enable
    Property<0X40020000 + 0X80, 1, 1> TCIE;                 // Transfer complete interrupt enable
    Property<0X40020000 + 0X80, 2, 1> HTIE;                 // Half Transfer interrupt enable
    Property<0X40020000 + 0X80, 3, 1> TEIE;                 // Transfer error interrupt enable
    Property<0X40020000 + 0X80, 4, 1> DIR;                  // Data transfer direction
    Property<0X40020000 + 0X80, 5, 1> CIRC;                 // Circular mode
    Property<0X40020000 + 0X80, 6, 1> PINC;                 // Peripheral increment mode
    Property<0X40020000 + 0X80, 7, 1> MINC;                 // Memory increment mode
    Property<0X40020000 + 0X80, 8, 2> PSIZE;                // Peripheral size
    Property<0X40020000 + 0X80, 10, 2> MSIZE;               // Memory size
    Property<0X40020000 + 0X80, 12, 2> PL;                  // Channel Priority level
    Property<0X40020000 + 0X80, 14, 1> MEM2MEM;             // Memory to memory mode
};


/*
    DMA controller @ 0X40020000
*/
struct DMA
{
    dma_isr ISR;               // DMA interrupt status register (DMA_ISR)
    dma_ifcr IFCR;             // DMA interrupt flag clear register (DMA_IFCR)
    dma_ccr1 CCR1;             // DMA channel configuration register (DMA_CCR)
    regrw CNDTR1;              // DMA channel 1 number of data register
    regrw CPAR1;               // DMA channel 1 peripheral address register
    regrw CMAR1;               // DMA channel 1 memory address register
    dma_ccr2 CCR2;             // DMA channel configuration register (DMA_CCR)
    regrw CNDTR2;              // DMA channel 2 number of data register
    regrw CPAR2;               // DMA channel 2 peripheral address register
    regrw CMAR2;               // DMA channel 2 memory address register
    dma_ccr3 CCR3;             // DMA channel configuration register (DMA_CCR)
    regrw CNDTR3;              // DMA channel 3 number of data register
    regrw CPAR3;               // DMA channel 3 peripheral address register
    regrw CMAR3;               // DMA channel 3 memory address register
    dma_ccr4 CCR4;             // DMA channel configuration register (DMA_CCR)
    regrw CNDTR4;              // DMA channel 4 number of data register
    regrw CPAR4;               // DMA channel 4 peripheral address register
    regrw CMAR4;               // DMA channel 4 memory address register
    dma_ccr5 CCR5;             // DMA channel configuration register (DMA_CCR)
    regrw CNDTR5;              // DMA channel 5 number of data register
    regrw CPAR5;               // DMA channel 5 peripheral address register
    regrw CMAR5;               // DMA channel 5 memory address register
    dma_ccr6 CCR6;             // DMA channel configuration register (DMA_CCR)
    regrw CNDTR6;              // DMA channel 6 number of data register
    regrw CPAR6;               // DMA channel 6 peripheral address register
    regrw CMAR6;               // DMA channel 6 memory address register
    dma_ccr7 CCR7;             // DMA channel configuration register (DMA_CCR)
    regrw CNDTR7;              // DMA channel 7 number of data register
    regrw CPAR7;               // DMA channel 7 peripheral address register
    regrw CMAR7;               // DMA channel 7 memory address register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40020000);}
};


enum class EXTI_IMR
{
    MR0,                       // Interrupt Mask on line 0
    MR1,                       // Interrupt Mask on line 1
    MR2,                       // Interrupt Mask on line 2
    MR3,                       // Interrupt Mask on line 3
    MR4,                       // Interrupt Mask on line 4
    MR5,                       // Interrupt Mask on line 5
    MR6,                       // Interrupt Mask on line 6
    MR7,                       // Interrupt Mask on line 7
    MR8,                       // Interrupt Mask on line 8
    MR9,                       // Interrupt Mask on line 9
    MR10,                      // Interrupt Mask on line 10
    MR11,                      // Interrupt Mask on line 11
    MR12,                      // Interrupt Mask on line 12
    MR13,                      // Interrupt Mask on line 13
    MR14,                      // Interrupt Mask on line 14
    MR15,                      // Interrupt Mask on line 15
    MR16,                      // Interrupt Mask on line 16
    MR17,                      // Interrupt Mask on line 17
    MR18,                      // Interrupt Mask on line 18
    MR19,                      // Interrupt Mask on line 19
    MR20,                      // Interrupt Mask on line 20
    MR21,                      // Interrupt Mask on line 21
    MR22,                      // Interrupt Mask on line 22
    MR23,                      // Interrupt Mask on line 23
    MR24,                      // Interrupt Mask on line 24
    MR25,                      // Interrupt Mask on line 25
    MR26,                      // Interrupt Mask on line 26
    MR27,                      // Interrupt Mask on line 27
};

/*
    Interrupt mask register (EXTI_IMR) @ 0X40010400 + 0X00
*/
struct exti_imr : public reg32bit<EXTI_IMR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010400 + 0X00, 0, 1> MR0;                  // Interrupt Mask on line 0
    Property<0X40010400 + 0X00, 1, 1> MR1;                  // Interrupt Mask on line 1
    Property<0X40010400 + 0X00, 2, 1> MR2;                  // Interrupt Mask on line 2
    Property<0X40010400 + 0X00, 3, 1> MR3;                  // Interrupt Mask on line 3
    Property<0X40010400 + 0X00, 4, 1> MR4;                  // Interrupt Mask on line 4
    Property<0X40010400 + 0X00, 5, 1> MR5;                  // Interrupt Mask on line 5
    Property<0X40010400 + 0X00, 6, 1> MR6;                  // Interrupt Mask on line 6
    Property<0X40010400 + 0X00, 7, 1> MR7;                  // Interrupt Mask on line 7
    Property<0X40010400 + 0X00, 8, 1> MR8;                  // Interrupt Mask on line 8
    Property<0X40010400 + 0X00, 9, 1> MR9;                  // Interrupt Mask on line 9
    Property<0X40010400 + 0X00, 10, 1> MR10;                // Interrupt Mask on line 10
    Property<0X40010400 + 0X00, 11, 1> MR11;                // Interrupt Mask on line 11
    Property<0X40010400 + 0X00, 12, 1> MR12;                // Interrupt Mask on line 12
    Property<0X40010400 + 0X00, 13, 1> MR13;                // Interrupt Mask on line 13
    Property<0X40010400 + 0X00, 14, 1> MR14;                // Interrupt Mask on line 14
    Property<0X40010400 + 0X00, 15, 1> MR15;                // Interrupt Mask on line 15
    Property<0X40010400 + 0X00, 16, 1> MR16;                // Interrupt Mask on line 16
    Property<0X40010400 + 0X00, 17, 1> MR17;                // Interrupt Mask on line 17
    Property<0X40010400 + 0X00, 18, 1> MR18;                // Interrupt Mask on line 18
    Property<0X40010400 + 0X00, 19, 1> MR19;                // Interrupt Mask on line 19
    Property<0X40010400 + 0X00, 20, 1> MR20;                // Interrupt Mask on line 20
    Property<0X40010400 + 0X00, 21, 1> MR21;                // Interrupt Mask on line 21
    Property<0X40010400 + 0X00, 22, 1> MR22;                // Interrupt Mask on line 22
    Property<0X40010400 + 0X00, 23, 1> MR23;                // Interrupt Mask on line 23
    Property<0X40010400 + 0X00, 24, 1> MR24;                // Interrupt Mask on line 24
    Property<0X40010400 + 0X00, 25, 1> MR25;                // Interrupt Mask on line 25
    Property<0X40010400 + 0X00, 26, 1> MR26;                // Interrupt Mask on line 26
    Property<0X40010400 + 0X00, 27, 1> MR27;                // Interrupt Mask on line 27
};


enum class EXTI_EMR
{
    MR0,                       // Event Mask on line 0
    MR1,                       // Event Mask on line 1
    MR2,                       // Event Mask on line 2
    MR3,                       // Event Mask on line 3
    MR4,                       // Event Mask on line 4
    MR5,                       // Event Mask on line 5
    MR6,                       // Event Mask on line 6
    MR7,                       // Event Mask on line 7
    MR8,                       // Event Mask on line 8
    MR9,                       // Event Mask on line 9
    MR10,                      // Event Mask on line 10
    MR11,                      // Event Mask on line 11
    MR12,                      // Event Mask on line 12
    MR13,                      // Event Mask on line 13
    MR14,                      // Event Mask on line 14
    MR15,                      // Event Mask on line 15
    MR16,                      // Event Mask on line 16
    MR17,                      // Event Mask on line 17
    MR18,                      // Event Mask on line 18
    MR19,                      // Event Mask on line 19
    MR20,                      // Event Mask on line 20
    MR21,                      // Event Mask on line 21
    MR22,                      // Event Mask on line 22
    MR23,                      // Event Mask on line 23
    MR24,                      // Event Mask on line 24
    MR25,                      // Event Mask on line 25
    MR26,                      // Event Mask on line 26
    MR27,                      // Event Mask on line 27
};

/*
    Event mask register (EXTI_EMR) @ 0X40010400 + 0X04
*/
struct exti_emr : public reg32bit<EXTI_EMR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010400 + 0X04, 0, 1> MR0;                  // Event Mask on line 0
    Property<0X40010400 + 0X04, 1, 1> MR1;                  // Event Mask on line 1
    Property<0X40010400 + 0X04, 2, 1> MR2;                  // Event Mask on line 2
    Property<0X40010400 + 0X04, 3, 1> MR3;                  // Event Mask on line 3
    Property<0X40010400 + 0X04, 4, 1> MR4;                  // Event Mask on line 4
    Property<0X40010400 + 0X04, 5, 1> MR5;                  // Event Mask on line 5
    Property<0X40010400 + 0X04, 6, 1> MR6;                  // Event Mask on line 6
    Property<0X40010400 + 0X04, 7, 1> MR7;                  // Event Mask on line 7
    Property<0X40010400 + 0X04, 8, 1> MR8;                  // Event Mask on line 8
    Property<0X40010400 + 0X04, 9, 1> MR9;                  // Event Mask on line 9
    Property<0X40010400 + 0X04, 10, 1> MR10;                // Event Mask on line 10
    Property<0X40010400 + 0X04, 11, 1> MR11;                // Event Mask on line 11
    Property<0X40010400 + 0X04, 12, 1> MR12;                // Event Mask on line 12
    Property<0X40010400 + 0X04, 13, 1> MR13;                // Event Mask on line 13
    Property<0X40010400 + 0X04, 14, 1> MR14;                // Event Mask on line 14
    Property<0X40010400 + 0X04, 15, 1> MR15;                // Event Mask on line 15
    Property<0X40010400 + 0X04, 16, 1> MR16;                // Event Mask on line 16
    Property<0X40010400 + 0X04, 17, 1> MR17;                // Event Mask on line 17
    Property<0X40010400 + 0X04, 18, 1> MR18;                // Event Mask on line 18
    Property<0X40010400 + 0X04, 19, 1> MR19;                // Event Mask on line 19
    Property<0X40010400 + 0X04, 20, 1> MR20;                // Event Mask on line 20
    Property<0X40010400 + 0X04, 21, 1> MR21;                // Event Mask on line 21
    Property<0X40010400 + 0X04, 22, 1> MR22;                // Event Mask on line 22
    Property<0X40010400 + 0X04, 23, 1> MR23;                // Event Mask on line 23
    Property<0X40010400 + 0X04, 24, 1> MR24;                // Event Mask on line 24
    Property<0X40010400 + 0X04, 25, 1> MR25;                // Event Mask on line 25
    Property<0X40010400 + 0X04, 26, 1> MR26;                // Event Mask on line 26
    Property<0X40010400 + 0X04, 27, 1> MR27;                // Event Mask on line 27
};


enum class EXTI_RTSR
{
    TR0,                       // Rising trigger event configuration of line 0
    TR1,                       // Rising trigger event configuration of line 1
    TR2,                       // Rising trigger event configuration of line 2
    TR3,                       // Rising trigger event configuration of line 3
    TR4,                       // Rising trigger event configuration of line 4
    TR5,                       // Rising trigger event configuration of line 5
    TR6,                       // Rising trigger event configuration of line 6
    TR7,                       // Rising trigger event configuration of line 7
    TR8,                       // Rising trigger event configuration of line 8
    TR9,                       // Rising trigger event configuration of line 9
    TR10,                      // Rising trigger event configuration of line 10
    TR11,                      // Rising trigger event configuration of line 11
    TR12,                      // Rising trigger event configuration of line 12
    TR13,                      // Rising trigger event configuration of line 13
    TR14,                      // Rising trigger event configuration of line 14
    TR15,                      // Rising trigger event configuration of line 15
    TR16,                      // Rising trigger event configuration of line 16
    TR17,                      // Rising trigger event configuration of line 17
    TR19 = 19,                 // Rising trigger event configuration of line 19
};

/*
    Rising Trigger selection register (EXTI_RTSR) @ 0X40010400 + 0X08
*/
struct exti_rtsr : public reg32bit<EXTI_RTSR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010400 + 0X08, 0, 1> TR0;                  // Rising trigger event configuration of line 0
    Property<0X40010400 + 0X08, 1, 1> TR1;                  // Rising trigger event configuration of line 1
    Property<0X40010400 + 0X08, 2, 1> TR2;                  // Rising trigger event configuration of line 2
    Property<0X40010400 + 0X08, 3, 1> TR3;                  // Rising trigger event configuration of line 3
    Property<0X40010400 + 0X08, 4, 1> TR4;                  // Rising trigger event configuration of line 4
    Property<0X40010400 + 0X08, 5, 1> TR5;                  // Rising trigger event configuration of line 5
    Property<0X40010400 + 0X08, 6, 1> TR6;                  // Rising trigger event configuration of line 6
    Property<0X40010400 + 0X08, 7, 1> TR7;                  // Rising trigger event configuration of line 7
    Property<0X40010400 + 0X08, 8, 1> TR8;                  // Rising trigger event configuration of line 8
    Property<0X40010400 + 0X08, 9, 1> TR9;                  // Rising trigger event configuration of line 9
    Property<0X40010400 + 0X08, 10, 1> TR10;                // Rising trigger event configuration of line 10
    Property<0X40010400 + 0X08, 11, 1> TR11;                // Rising trigger event configuration of line 11
    Property<0X40010400 + 0X08, 12, 1> TR12;                // Rising trigger event configuration of line 12
    Property<0X40010400 + 0X08, 13, 1> TR13;                // Rising trigger event configuration of line 13
    Property<0X40010400 + 0X08, 14, 1> TR14;                // Rising trigger event configuration of line 14
    Property<0X40010400 + 0X08, 15, 1> TR15;                // Rising trigger event configuration of line 15
    Property<0X40010400 + 0X08, 16, 1> TR16;                // Rising trigger event configuration of line 16
    Property<0X40010400 + 0X08, 17, 1> TR17;                // Rising trigger event configuration of line 17
    Property<0X40010400 + 0X08, 19, 1> TR19;                // Rising trigger event configuration of line 19
};


enum class EXTI_FTSR
{
    TR0,                       // Falling trigger event configuration of line 0
    TR1,                       // Falling trigger event configuration of line 1
    TR2,                       // Falling trigger event configuration of line 2
    TR3,                       // Falling trigger event configuration of line 3
    TR4,                       // Falling trigger event configuration of line 4
    TR5,                       // Falling trigger event configuration of line 5
    TR6,                       // Falling trigger event configuration of line 6
    TR7,                       // Falling trigger event configuration of line 7
    TR8,                       // Falling trigger event configuration of line 8
    TR9,                       // Falling trigger event configuration of line 9
    TR10,                      // Falling trigger event configuration of line 10
    TR11,                      // Falling trigger event configuration of line 11
    TR12,                      // Falling trigger event configuration of line 12
    TR13,                      // Falling trigger event configuration of line 13
    TR14,                      // Falling trigger event configuration of line 14
    TR15,                      // Falling trigger event configuration of line 15
    TR16,                      // Falling trigger event configuration of line 16
    TR17,                      // Falling trigger event configuration of line 17
    TR19 = 19,                 // Falling trigger event configuration of line 19
};

/*
    Falling Trigger selection register (EXTI_FTSR) @ 0X40010400 + 0X0C
*/
struct exti_ftsr : public reg32bit<EXTI_FTSR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010400 + 0X0C, 0, 1> TR0;                  // Falling trigger event configuration of line 0
    Property<0X40010400 + 0X0C, 1, 1> TR1;                  // Falling trigger event configuration of line 1
    Property<0X40010400 + 0X0C, 2, 1> TR2;                  // Falling trigger event configuration of line 2
    Property<0X40010400 + 0X0C, 3, 1> TR3;                  // Falling trigger event configuration of line 3
    Property<0X40010400 + 0X0C, 4, 1> TR4;                  // Falling trigger event configuration of line 4
    Property<0X40010400 + 0X0C, 5, 1> TR5;                  // Falling trigger event configuration of line 5
    Property<0X40010400 + 0X0C, 6, 1> TR6;                  // Falling trigger event configuration of line 6
    Property<0X40010400 + 0X0C, 7, 1> TR7;                  // Falling trigger event configuration of line 7
    Property<0X40010400 + 0X0C, 8, 1> TR8;                  // Falling trigger event configuration of line 8
    Property<0X40010400 + 0X0C, 9, 1> TR9;                  // Falling trigger event configuration of line 9
    Property<0X40010400 + 0X0C, 10, 1> TR10;                // Falling trigger event configuration of line 10
    Property<0X40010400 + 0X0C, 11, 1> TR11;                // Falling trigger event configuration of line 11
    Property<0X40010400 + 0X0C, 12, 1> TR12;                // Falling trigger event configuration of line 12
    Property<0X40010400 + 0X0C, 13, 1> TR13;                // Falling trigger event configuration of line 13
    Property<0X40010400 + 0X0C, 14, 1> TR14;                // Falling trigger event configuration of line 14
    Property<0X40010400 + 0X0C, 15, 1> TR15;                // Falling trigger event configuration of line 15
    Property<0X40010400 + 0X0C, 16, 1> TR16;                // Falling trigger event configuration of line 16
    Property<0X40010400 + 0X0C, 17, 1> TR17;                // Falling trigger event configuration of line 17
    Property<0X40010400 + 0X0C, 19, 1> TR19;                // Falling trigger event configuration of line 19
};


enum class EXTI_SWIER
{
    SWIER0,                    // Software Interrupt on line 0
    SWIER1,                    // Software Interrupt on line 1
    SWIER2,                    // Software Interrupt on line 2
    SWIER3,                    // Software Interrupt on line 3
    SWIER4,                    // Software Interrupt on line 4
    SWIER5,                    // Software Interrupt on line 5
    SWIER6,                    // Software Interrupt on line 6
    SWIER7,                    // Software Interrupt on line 7
    SWIER8,                    // Software Interrupt on line 8
    SWIER9,                    // Software Interrupt on line 9
    SWIER10,                   // Software Interrupt on line 10
    SWIER11,                   // Software Interrupt on line 11
    SWIER12,                   // Software Interrupt on line 12
    SWIER13,                   // Software Interrupt on line 13
    SWIER14,                   // Software Interrupt on line 14
    SWIER15,                   // Software Interrupt on line 15
    SWIER16,                   // Software Interrupt on line 16
    SWIER17,                   // Software Interrupt on line 17
    SWIER19 = 19,              // Software Interrupt on line 19
};

/*
    Software interrupt event register (EXTI_SWIER) @ 0X40010400 + 0X10
*/
struct exti_swier : public reg32bit<EXTI_SWIER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010400 + 0X10, 0, 1> SWIER0;               // Software Interrupt on line 0
    Property<0X40010400 + 0X10, 1, 1> SWIER1;               // Software Interrupt on line 1
    Property<0X40010400 + 0X10, 2, 1> SWIER2;               // Software Interrupt on line 2
    Property<0X40010400 + 0X10, 3, 1> SWIER3;               // Software Interrupt on line 3
    Property<0X40010400 + 0X10, 4, 1> SWIER4;               // Software Interrupt on line 4
    Property<0X40010400 + 0X10, 5, 1> SWIER5;               // Software Interrupt on line 5
    Property<0X40010400 + 0X10, 6, 1> SWIER6;               // Software Interrupt on line 6
    Property<0X40010400 + 0X10, 7, 1> SWIER7;               // Software Interrupt on line 7
    Property<0X40010400 + 0X10, 8, 1> SWIER8;               // Software Interrupt on line 8
    Property<0X40010400 + 0X10, 9, 1> SWIER9;               // Software Interrupt on line 9
    Property<0X40010400 + 0X10, 10, 1> SWIER10;             // Software Interrupt on line 10
    Property<0X40010400 + 0X10, 11, 1> SWIER11;             // Software Interrupt on line 11
    Property<0X40010400 + 0X10, 12, 1> SWIER12;             // Software Interrupt on line 12
    Property<0X40010400 + 0X10, 13, 1> SWIER13;             // Software Interrupt on line 13
    Property<0X40010400 + 0X10, 14, 1> SWIER14;             // Software Interrupt on line 14
    Property<0X40010400 + 0X10, 15, 1> SWIER15;             // Software Interrupt on line 15
    Property<0X40010400 + 0X10, 16, 1> SWIER16;             // Software Interrupt on line 16
    Property<0X40010400 + 0X10, 17, 1> SWIER17;             // Software Interrupt on line 17
    Property<0X40010400 + 0X10, 19, 1> SWIER19;             // Software Interrupt on line 19
};


enum class EXTI_PR
{
    PR0,                       // Pending bit 0
    PR1,                       // Pending bit 1
    PR2,                       // Pending bit 2
    PR3,                       // Pending bit 3
    PR4,                       // Pending bit 4
    PR5,                       // Pending bit 5
    PR6,                       // Pending bit 6
    PR7,                       // Pending bit 7
    PR8,                       // Pending bit 8
    PR9,                       // Pending bit 9
    PR10,                      // Pending bit 10
    PR11,                      // Pending bit 11
    PR12,                      // Pending bit 12
    PR13,                      // Pending bit 13
    PR14,                      // Pending bit 14
    PR15,                      // Pending bit 15
    PR16,                      // Pending bit 16
    PR17,                      // Pending bit 17
    PR19 = 19,                 // Pending bit 19
};

/*
    Pending register (EXTI_PR) @ 0X40010400 + 0X14
*/
struct exti_pr : public reg32bit<EXTI_PR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010400 + 0X14, 0, 1> PR0;                  // Pending bit 0
    Property<0X40010400 + 0X14, 1, 1> PR1;                  // Pending bit 1
    Property<0X40010400 + 0X14, 2, 1> PR2;                  // Pending bit 2
    Property<0X40010400 + 0X14, 3, 1> PR3;                  // Pending bit 3
    Property<0X40010400 + 0X14, 4, 1> PR4;                  // Pending bit 4
    Property<0X40010400 + 0X14, 5, 1> PR5;                  // Pending bit 5
    Property<0X40010400 + 0X14, 6, 1> PR6;                  // Pending bit 6
    Property<0X40010400 + 0X14, 7, 1> PR7;                  // Pending bit 7
    Property<0X40010400 + 0X14, 8, 1> PR8;                  // Pending bit 8
    Property<0X40010400 + 0X14, 9, 1> PR9;                  // Pending bit 9
    Property<0X40010400 + 0X14, 10, 1> PR10;                // Pending bit 10
    Property<0X40010400 + 0X14, 11, 1> PR11;                // Pending bit 11
    Property<0X40010400 + 0X14, 12, 1> PR12;                // Pending bit 12
    Property<0X40010400 + 0X14, 13, 1> PR13;                // Pending bit 13
    Property<0X40010400 + 0X14, 14, 1> PR14;                // Pending bit 14
    Property<0X40010400 + 0X14, 15, 1> PR15;                // Pending bit 15
    Property<0X40010400 + 0X14, 16, 1> PR16;                // Pending bit 16
    Property<0X40010400 + 0X14, 17, 1> PR17;                // Pending bit 17
    Property<0X40010400 + 0X14, 19, 1> PR19;                // Pending bit 19
};


/*
    External interrupt/event controller @ 0X40010400
*/
struct EXTI
{
    exti_imr IMR;              // Interrupt mask register (EXTI_IMR)
    exti_emr EMR;              // Event mask register (EXTI_EMR)
    exti_rtsr RTSR;            // Rising Trigger selection register (EXTI_RTSR)
    exti_ftsr FTSR;            // Falling Trigger selection register (EXTI_FTSR)
    exti_swier SWIER;          // Software interrupt event register (EXTI_SWIER)
    exti_pr PR;                // Pending register (EXTI_PR)

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40010400);}
};


enum class Flash_ACR
{
    LATENCY,                   // LATENCY
    PRFTBE = 4,                // PRFTBE
    PRFTBS,                    // PRFTBS
};

/*
    Flash access control register @ 0X40022000 + 0X00
*/
struct flash_acr : public reg32bit<Flash_ACR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40022000 + 0X00, 0, 3> LATENCY;              // LATENCY
    Property<0X40022000 + 0X00, 4, 1> PRFTBE;               // PRFTBE
    Property<0X40022000 + 0X00, 5, 1> PRFTBS;               // PRFTBS
};


enum class Flash_SR
{
    BSY,                       // Busy
    PGERR = 2,                 // Programming error
    WRPRT = 4,                 // Write protection error
    EOP,                       // End of operation
};

/*
    Flash status register @ 0X40022000 + 0X0C
*/
struct flash_sr : public reg32bit<Flash_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40022000 + 0X0C, 0, 1> BSY;                  // Busy
    Property<0X40022000 + 0X0C, 2, 1> PGERR;                // Programming error
    Property<0X40022000 + 0X0C, 4, 1> WRPRT;                // Write protection error
    Property<0X40022000 + 0X0C, 5, 1> EOP;                  // End of operation
};


enum class Flash_CR
{
    PG,                        // Programming
    PER,                       // Page erase
    MER,                       // Mass erase
    OPTPG = 4,                 // Option byte programming
    OPTER,                     // Option byte erase
    STRT,                      // Start
    LOCK,                      // Lock
    OPTWRE = 9,                // Option bytes write enable
    ERRIE,                     // Error interrupt enable
    EOPIE = 12,                // End of operation interrupt enable
    FORCE_OPTLOAD,             // Force option byte loading
};

/*
    Flash control register @ 0X40022000 + 0X10
*/
struct flash_cr : public reg32bit<Flash_CR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40022000 + 0X10, 0, 1> PG;                   // Programming
    Property<0X40022000 + 0X10, 1, 1> PER;                  // Page erase
    Property<0X40022000 + 0X10, 2, 1> MER;                  // Mass erase
    Property<0X40022000 + 0X10, 4, 1> OPTPG;                // Option byte programming
    Property<0X40022000 + 0X10, 5, 1> OPTER;                // Option byte erase
    Property<0X40022000 + 0X10, 6, 1> STRT;                 // Start
    Property<0X40022000 + 0X10, 7, 1> LOCK;                 // Lock
    Property<0X40022000 + 0X10, 9, 1> OPTWRE;               // Option bytes write enable
    Property<0X40022000 + 0X10, 10, 1> ERRIE;               // Error interrupt enable
    Property<0X40022000 + 0X10, 12, 1> EOPIE;               // End of operation interrupt enable
    Property<0X40022000 + 0X10, 13, 1> FORCE_OPTLOAD;       // Force option byte loading
};


enum class Flash_OBR
{
    OPTERR,                    // Option byte error
    LEVEL1_PROT,               // Level 1 protection status
    LEVEL2_PROT,               // Level 2 protection status
    WDG_SW = 8,                // WDG_SW
    nRST_STOP,                 // nRST_STOP
    nRST_STDBY,                // nRST_STDBY
    BOOT1 = 12,                // BOOT1
    VDDA_MONITOR,              // VDDA_MONITOR
    Data0 = 16,                // Data0
    Data1 = 24,                // Data1
};

/*
    Option byte register @ 0X40022000 + 0X1C
*/
struct flash_obr : public reg32bit<Flash_OBR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40022000 + 0X1C, 0, 1> OPTERR;               // Option byte error
    Property<0X40022000 + 0X1C, 1, 1> LEVEL1_PROT;          // Level 1 protection status
    Property<0X40022000 + 0X1C, 2, 1> LEVEL2_PROT;          // Level 2 protection status
    Property<0X40022000 + 0X1C, 8, 1> WDG_SW;               // WDG_SW
    Property<0X40022000 + 0X1C, 9, 1> nRST_STOP;            // nRST_STOP
    Property<0X40022000 + 0X1C, 10, 1> nRST_STDBY;          // nRST_STDBY
    Property<0X40022000 + 0X1C, 12, 1> BOOT1;               // BOOT1
    Property<0X40022000 + 0X1C, 13, 1> VDDA_MONITOR;        // VDDA_MONITOR
    Property<0X40022000 + 0X1C, 16, 8> Data0;               // Data0
    Property<0X40022000 + 0X1C, 24, 8> Data1;               // Data1
};


/*
    Flash @ 0X40022000
*/
struct Flash
{
    flash_acr ACR;             // Flash access control register
    regrw KEYR;                // Flash key register
    regrw OPTKEYR;             // Flash option key register
    flash_sr SR;               // Flash status register
    flash_cr CR;               // Flash control register
    regrw AR;                  // Flash address register
    flash_obr OBR;             // Option byte register
    regrw WRPR;                // Write protection register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40022000);}
};


enum class I2C1_CR1
{
    PE,                        // Peripheral enable
    TXIE,                      // TX Interrupt enable
    RXIE,                      // RX Interrupt enable
    ADDRIE,                    // Address match interrupt enable (slave only)
    NACKIE,                    // Not acknowledge received interrupt enable
    STOPIE,                    // STOP detection Interrupt enable
    TCIE,                      // Transfer Complete interrupt enable
    ERRIE,                     // Error interrupts enable
    DNF,                       // Digital noise filter
    ANFOFF = 12,               // Analog noise filter OFF
    SWRST,                     // Software reset
    TXDMAEN,                   // DMA transmission requests enable
    RXDMAEN,                   // DMA reception requests enable
    SBC,                       // Slave byte control
    NOSTRETCH,                 // Clock stretching disable
    WUPEN,                     // Wakeup from STOP enable
    GCEN,                      // General call enable
    SMBHEN,                    // SMBus Host address enable
    SMBDEN,                    // SMBus Device Default address enable
    ALERTEN,                   // SMBUS alert enable
    PECEN,                     // PEC enable
};

/*
    Control register 1 @ 0X40005400 + 0X00
*/
struct i2c1_cr1 : public reg32bit<I2C1_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005400 + 0X00, 0, 1> PE;                   // Peripheral enable
    Property<0X40005400 + 0X00, 1, 1> TXIE;                 // TX Interrupt enable
    Property<0X40005400 + 0X00, 2, 1> RXIE;                 // RX Interrupt enable
    Property<0X40005400 + 0X00, 3, 1> ADDRIE;               // Address match interrupt enable (slave only)
    Property<0X40005400 + 0X00, 4, 1> NACKIE;               // Not acknowledge received interrupt enable
    Property<0X40005400 + 0X00, 5, 1> STOPIE;               // STOP detection Interrupt enable
    Property<0X40005400 + 0X00, 6, 1> TCIE;                 // Transfer Complete interrupt enable
    Property<0X40005400 + 0X00, 7, 1> ERRIE;                // Error interrupts enable
    Property<0X40005400 + 0X00, 8, 4> DNF;                  // Digital noise filter
    Property<0X40005400 + 0X00, 12, 1> ANFOFF;              // Analog noise filter OFF
    Property<0X40005400 + 0X00, 13, 1> SWRST;               // Software reset
    Property<0X40005400 + 0X00, 14, 1> TXDMAEN;             // DMA transmission requests enable
    Property<0X40005400 + 0X00, 15, 1> RXDMAEN;             // DMA reception requests enable
    Property<0X40005400 + 0X00, 16, 1> SBC;                 // Slave byte control
    Property<0X40005400 + 0X00, 17, 1> NOSTRETCH;           // Clock stretching disable
    Property<0X40005400 + 0X00, 18, 1> WUPEN;               // Wakeup from STOP enable
    Property<0X40005400 + 0X00, 19, 1> GCEN;                // General call enable
    Property<0X40005400 + 0X00, 20, 1> SMBHEN;              // SMBus Host address enable
    Property<0X40005400 + 0X00, 21, 1> SMBDEN;              // SMBus Device Default address enable
    Property<0X40005400 + 0X00, 22, 1> ALERTEN;             // SMBUS alert enable
    Property<0X40005400 + 0X00, 23, 1> PECEN;               // PEC enable
};


enum class I2C1_CR2
{
    SADD0,                     // Slave address bit 0 (master mode)
    SADD1,                     // Slave address bit 7:1 (master mode)
    SADD8 = 8,                 // Slave address bit 9:8 (master mode)
    RD_WRN = 10,               // Transfer direction (master mode)
    ADD10,                     // 10-bit addressing mode (master mode)
    HEAD10R,                   // 10-bit address header only read direction (master receiver mode)
    START,                     // Start generation
    STOP,                      // Stop generation (master mode)
    NACK,                      // NACK generation (slave mode)
    NBYTES,                    // Number of bytes
    RELOAD = 24,               // NBYTES reload mode
    AUTOEND,                   // Automatic end mode (master mode)
    PECBYTE,                   // Packet error checking byte
};

/*
    Control register 2 @ 0X40005400 + 0X04
*/
struct i2c1_cr2 : public reg32bit<I2C1_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005400 + 0X04, 0, 1> SADD0;                // Slave address bit 0 (master mode)
    Property<0X40005400 + 0X04, 1, 7> SADD1;                // Slave address bit 7:1 (master mode)
    Property<0X40005400 + 0X04, 8, 2> SADD8;                // Slave address bit 9:8 (master mode)
    Property<0X40005400 + 0X04, 10, 1> RD_WRN;              // Transfer direction (master mode)
    Property<0X40005400 + 0X04, 11, 1> ADD10;               // 10-bit addressing mode (master mode)
    Property<0X40005400 + 0X04, 12, 1> HEAD10R;             // 10-bit address header only read direction (master receiver mode)
    Property<0X40005400 + 0X04, 13, 1> START;               // Start generation
    Property<0X40005400 + 0X04, 14, 1> STOP;                // Stop generation (master mode)
    Property<0X40005400 + 0X04, 15, 1> NACK;                // NACK generation (slave mode)
    Property<0X40005400 + 0X04, 16, 8> NBYTES;              // Number of bytes
    Property<0X40005400 + 0X04, 24, 1> RELOAD;              // NBYTES reload mode
    Property<0X40005400 + 0X04, 25, 1> AUTOEND;             // Automatic end mode (master mode)
    Property<0X40005400 + 0X04, 26, 1> PECBYTE;             // Packet error checking byte
};


enum class I2C1_OAR1
{
    OA1_0,                     // Interface address
    OA1_1,                     // Interface address
    OA1_8 = 8,                 // Interface address
    OA1MODE = 10,              // Own Address 1 10-bit mode
    OA1EN = 15,                // Own Address 1 enable
};

/*
    Own address register 1 @ 0X40005400 + 0X08
*/
struct i2c1_oar1 : public reg32bit<I2C1_OAR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005400 + 0X08, 0, 1> OA1_0;                // Interface address
    Property<0X40005400 + 0X08, 1, 7> OA1_1;                // Interface address
    Property<0X40005400 + 0X08, 8, 2> OA1_8;                // Interface address
    Property<0X40005400 + 0X08, 10, 1> OA1MODE;             // Own Address 1 10-bit mode
    Property<0X40005400 + 0X08, 15, 1> OA1EN;               // Own Address 1 enable
};


enum class I2C1_OAR2
{
    OA2 = 1,                   // Interface address
    OA2MSK = 8,                // Own Address 2 masks
    OA2EN = 15,                // Own Address 2 enable
};

/*
    Own address register 2 @ 0X40005400 + 0X0C
*/
struct i2c1_oar2 : public reg32bit<I2C1_OAR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005400 + 0X0C, 1, 7> OA2;                  // Interface address
    Property<0X40005400 + 0X0C, 8, 3> OA2MSK;               // Own Address 2 masks
    Property<0X40005400 + 0X0C, 15, 1> OA2EN;               // Own Address 2 enable
};


enum class I2C1_TIMINGR
{
    SCLL,                      // SCL low period (master mode)
    SCLH = 8,                  // SCL high period (master mode)
    SDADEL = 16,               // Data hold time
    SCLDEL = 20,               // Data setup time
    PRESC = 28,                // Timing prescaler
};

/*
    Timing register @ 0X40005400 + 0X10
*/
struct i2c1_timingr : public reg32bit<I2C1_TIMINGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005400 + 0X10, 0, 8> SCLL;                 // SCL low period (master mode)
    Property<0X40005400 + 0X10, 8, 8> SCLH;                 // SCL high period (master mode)
    Property<0X40005400 + 0X10, 16, 4> SDADEL;              // Data hold time
    Property<0X40005400 + 0X10, 20, 4> SCLDEL;              // Data setup time
    Property<0X40005400 + 0X10, 28, 4> PRESC;               // Timing prescaler
};


enum class I2C1_TIMEOUTR
{
    TIMEOUTA,                  // Bus timeout A
    TIDLE = 12,                // Idle clock timeout detection
    TIMOUTEN = 15,             // Clock timeout enable
    TIMEOUTB,                  // Bus timeout B
    TEXTEN = 31,               // Extended clock timeout enable
};

/*
    Status register 1 @ 0X40005400 + 0X14
*/
struct i2c1_timeoutr : public reg32bit<I2C1_TIMEOUTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005400 + 0X14, 0, 12> TIMEOUTA;            // Bus timeout A
    Property<0X40005400 + 0X14, 12, 1> TIDLE;               // Idle clock timeout detection
    Property<0X40005400 + 0X14, 15, 1> TIMOUTEN;            // Clock timeout enable
    Property<0X40005400 + 0X14, 16, 12> TIMEOUTB;           // Bus timeout B
    Property<0X40005400 + 0X14, 31, 1> TEXTEN;              // Extended clock timeout enable
};


enum class I2C1_ISR
{
    TXE,                       // Transmit data register empty (transmitters)
    TXIS,                      // Transmit interrupt status (transmitters)
    RXNE,                      // Receive data register not empty (receivers)
    ADDR,                      // Address matched (slave mode)
    NACKF,                     // Not acknowledge received flag
    STOPF,                     // Stop detection flag
    TC,                        // Transfer Complete (master mode)
    TCR,                       // Transfer Complete Reload
    BERR,                      // Bus error
    ARLO,                      // Arbitration lost
    OVR,                       // Overrun/Underrun (slave mode)
    PECERR,                    // PEC Error in reception
    TIMEOUT,                   // Timeout or t_low detection flag
    ALERT,                     // SMBus alert
    BUSY = 15,                 // Bus busy
    DIR,                       // Transfer direction (Slave mode)
    ADDCODE,                   // Address match code (Slave mode)
};

/*
    Interrupt and Status register @ 0X40005400 + 0X18
*/
struct i2c1_isr : public reg32bit<I2C1_ISR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005400 + 0X18, 0, 1> TXE;                  // Transmit data register empty (transmitters)
    Property<0X40005400 + 0X18, 1, 1> TXIS;                 // Transmit interrupt status (transmitters)
    Property<0X40005400 + 0X18, 2, 1> RXNE;                 // Receive data register not empty (receivers)
    Property<0X40005400 + 0X18, 3, 1> ADDR;                 // Address matched (slave mode)
    Property<0X40005400 + 0X18, 4, 1> NACKF;                // Not acknowledge received flag
    Property<0X40005400 + 0X18, 5, 1> STOPF;                // Stop detection flag
    Property<0X40005400 + 0X18, 6, 1> TC;                   // Transfer Complete (master mode)
    Property<0X40005400 + 0X18, 7, 1> TCR;                  // Transfer Complete Reload
    Property<0X40005400 + 0X18, 8, 1> BERR;                 // Bus error
    Property<0X40005400 + 0X18, 9, 1> ARLO;                 // Arbitration lost
    Property<0X40005400 + 0X18, 10, 1> OVR;                 // Overrun/Underrun (slave mode)
    Property<0X40005400 + 0X18, 11, 1> PECERR;              // PEC Error in reception
    Property<0X40005400 + 0X18, 12, 1> TIMEOUT;             // Timeout or t_low detection flag
    Property<0X40005400 + 0X18, 13, 1> ALERT;               // SMBus alert
    Property<0X40005400 + 0X18, 15, 1> BUSY;                // Bus busy
    Property<0X40005400 + 0X18, 16, 1> DIR;                 // Transfer direction (Slave mode)
    Property<0X40005400 + 0X18, 17, 7> ADDCODE;             // Address match code (Slave mode)
};


enum class I2C1_ICR
{
    ADDRCF = 3,                // Address Matched flag clear
    NACKCF,                    // Not Acknowledge flag clear
    STOPCF,                    // Stop detection flag clear
    BERRCF = 8,                // Bus error flag clear
    ARLOCF,                    // Arbitration lost flag clear
    OVRCF,                     // Overrun/Underrun flag clear
    PECCF,                     // PEC Error flag clear
    TIMOUTCF,                  // Timeout detection flag clear
    ALERTCF,                   // Alert flag clear
};

/*
    Interrupt clear register @ 0X40005400 + 0X1C
*/
struct i2c1_icr : public reg32bit<I2C1_ICR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005400 + 0X1C, 3, 1> ADDRCF;               // Address Matched flag clear
    Property<0X40005400 + 0X1C, 4, 1> NACKCF;               // Not Acknowledge flag clear
    Property<0X40005400 + 0X1C, 5, 1> STOPCF;               // Stop detection flag clear
    Property<0X40005400 + 0X1C, 8, 1> BERRCF;               // Bus error flag clear
    Property<0X40005400 + 0X1C, 9, 1> ARLOCF;               // Arbitration lost flag clear
    Property<0X40005400 + 0X1C, 10, 1> OVRCF;               // Overrun/Underrun flag clear
    Property<0X40005400 + 0X1C, 11, 1> PECCF;               // PEC Error flag clear
    Property<0X40005400 + 0X1C, 12, 1> TIMOUTCF;            // Timeout detection flag clear
    Property<0X40005400 + 0X1C, 13, 1> ALERTCF;             // Alert flag clear
};


/*
    Inter-integrated circuit @ 0X40005400
*/
struct I2C1
{
    i2c1_cr1 CR1;              // Control register 1
    i2c1_cr2 CR2;              // Control register 2
    i2c1_oar1 OAR1;            // Own address register 1
    i2c1_oar2 OAR2;            // Own address register 2
    i2c1_timingr TIMINGR;      // Timing register
    i2c1_timeoutr TIMEOUTR;    // Status register 1
    i2c1_isr ISR;              // Interrupt and Status register
    i2c1_icr ICR;              // Interrupt clear register
    regrw PECR;                // PEC register
    regrw RXDR;                // Receive data register
    regrw TXDR;                // Transmit data register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40005400);}
};


enum class I2C2_CR1
{
    PE,                        // Peripheral enable
    TXIE,                      // TX Interrupt enable
    RXIE,                      // RX Interrupt enable
    ADDRIE,                    // Address match interrupt enable (slave only)
    NACKIE,                    // Not acknowledge received interrupt enable
    STOPIE,                    // STOP detection Interrupt enable
    TCIE,                      // Transfer Complete interrupt enable
    ERRIE,                     // Error interrupts enable
    DNF,                       // Digital noise filter
    ANFOFF = 12,               // Analog noise filter OFF
    SWRST,                     // Software reset
    TXDMAEN,                   // DMA transmission requests enable
    RXDMAEN,                   // DMA reception requests enable
    SBC,                       // Slave byte control
    NOSTRETCH,                 // Clock stretching disable
    WUPEN,                     // Wakeup from STOP enable
    GCEN,                      // General call enable
    SMBHEN,                    // SMBus Host address enable
    SMBDEN,                    // SMBus Device Default address enable
    ALERTEN,                   // SMBUS alert enable
    PECEN,                     // PEC enable
};

/*
    Control register 1 @ 0X40005800 + 0X00
*/
struct i2c2_cr1 : public reg32bit<I2C2_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005800 + 0X00, 0, 1> PE;                   // Peripheral enable
    Property<0X40005800 + 0X00, 1, 1> TXIE;                 // TX Interrupt enable
    Property<0X40005800 + 0X00, 2, 1> RXIE;                 // RX Interrupt enable
    Property<0X40005800 + 0X00, 3, 1> ADDRIE;               // Address match interrupt enable (slave only)
    Property<0X40005800 + 0X00, 4, 1> NACKIE;               // Not acknowledge received interrupt enable
    Property<0X40005800 + 0X00, 5, 1> STOPIE;               // STOP detection Interrupt enable
    Property<0X40005800 + 0X00, 6, 1> TCIE;                 // Transfer Complete interrupt enable
    Property<0X40005800 + 0X00, 7, 1> ERRIE;                // Error interrupts enable
    Property<0X40005800 + 0X00, 8, 4> DNF;                  // Digital noise filter
    Property<0X40005800 + 0X00, 12, 1> ANFOFF;              // Analog noise filter OFF
    Property<0X40005800 + 0X00, 13, 1> SWRST;               // Software reset
    Property<0X40005800 + 0X00, 14, 1> TXDMAEN;             // DMA transmission requests enable
    Property<0X40005800 + 0X00, 15, 1> RXDMAEN;             // DMA reception requests enable
    Property<0X40005800 + 0X00, 16, 1> SBC;                 // Slave byte control
    Property<0X40005800 + 0X00, 17, 1> NOSTRETCH;           // Clock stretching disable
    Property<0X40005800 + 0X00, 18, 1> WUPEN;               // Wakeup from STOP enable
    Property<0X40005800 + 0X00, 19, 1> GCEN;                // General call enable
    Property<0X40005800 + 0X00, 20, 1> SMBHEN;              // SMBus Host address enable
    Property<0X40005800 + 0X00, 21, 1> SMBDEN;              // SMBus Device Default address enable
    Property<0X40005800 + 0X00, 22, 1> ALERTEN;             // SMBUS alert enable
    Property<0X40005800 + 0X00, 23, 1> PECEN;               // PEC enable
};


enum class I2C2_CR2
{
    SADD0,                     // Slave address bit 0 (master mode)
    SADD1,                     // Slave address bit 7:1 (master mode)
    SADD8 = 8,                 // Slave address bit 9:8 (master mode)
    RD_WRN = 10,               // Transfer direction (master mode)
    ADD10,                     // 10-bit addressing mode (master mode)
    HEAD10R,                   // 10-bit address header only read direction (master receiver mode)
    START,                     // Start generation
    STOP,                      // Stop generation (master mode)
    NACK,                      // NACK generation (slave mode)
    NBYTES,                    // Number of bytes
    RELOAD = 24,               // NBYTES reload mode
    AUTOEND,                   // Automatic end mode (master mode)
    PECBYTE,                   // Packet error checking byte
};

/*
    Control register 2 @ 0X40005800 + 0X04
*/
struct i2c2_cr2 : public reg32bit<I2C2_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005800 + 0X04, 0, 1> SADD0;                // Slave address bit 0 (master mode)
    Property<0X40005800 + 0X04, 1, 7> SADD1;                // Slave address bit 7:1 (master mode)
    Property<0X40005800 + 0X04, 8, 2> SADD8;                // Slave address bit 9:8 (master mode)
    Property<0X40005800 + 0X04, 10, 1> RD_WRN;              // Transfer direction (master mode)
    Property<0X40005800 + 0X04, 11, 1> ADD10;               // 10-bit addressing mode (master mode)
    Property<0X40005800 + 0X04, 12, 1> HEAD10R;             // 10-bit address header only read direction (master receiver mode)
    Property<0X40005800 + 0X04, 13, 1> START;               // Start generation
    Property<0X40005800 + 0X04, 14, 1> STOP;                // Stop generation (master mode)
    Property<0X40005800 + 0X04, 15, 1> NACK;                // NACK generation (slave mode)
    Property<0X40005800 + 0X04, 16, 8> NBYTES;              // Number of bytes
    Property<0X40005800 + 0X04, 24, 1> RELOAD;              // NBYTES reload mode
    Property<0X40005800 + 0X04, 25, 1> AUTOEND;             // Automatic end mode (master mode)
    Property<0X40005800 + 0X04, 26, 1> PECBYTE;             // Packet error checking byte
};


enum class I2C2_OAR1
{
    OA1_0,                     // Interface address
    OA1_1,                     // Interface address
    OA1_8 = 8,                 // Interface address
    OA1MODE = 10,              // Own Address 1 10-bit mode
    OA1EN = 15,                // Own Address 1 enable
};

/*
    Own address register 1 @ 0X40005800 + 0X08
*/
struct i2c2_oar1 : public reg32bit<I2C2_OAR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005800 + 0X08, 0, 1> OA1_0;                // Interface address
    Property<0X40005800 + 0X08, 1, 7> OA1_1;                // Interface address
    Property<0X40005800 + 0X08, 8, 2> OA1_8;                // Interface address
    Property<0X40005800 + 0X08, 10, 1> OA1MODE;             // Own Address 1 10-bit mode
    Property<0X40005800 + 0X08, 15, 1> OA1EN;               // Own Address 1 enable
};


enum class I2C2_OAR2
{
    OA2 = 1,                   // Interface address
    OA2MSK = 8,                // Own Address 2 masks
    OA2EN = 15,                // Own Address 2 enable
};

/*
    Own address register 2 @ 0X40005800 + 0X0C
*/
struct i2c2_oar2 : public reg32bit<I2C2_OAR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005800 + 0X0C, 1, 7> OA2;                  // Interface address
    Property<0X40005800 + 0X0C, 8, 3> OA2MSK;               // Own Address 2 masks
    Property<0X40005800 + 0X0C, 15, 1> OA2EN;               // Own Address 2 enable
};


enum class I2C2_TIMINGR
{
    SCLL,                      // SCL low period (master mode)
    SCLH = 8,                  // SCL high period (master mode)
    SDADEL = 16,               // Data hold time
    SCLDEL = 20,               // Data setup time
    PRESC = 28,                // Timing prescaler
};

/*
    Timing register @ 0X40005800 + 0X10
*/
struct i2c2_timingr : public reg32bit<I2C2_TIMINGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005800 + 0X10, 0, 8> SCLL;                 // SCL low period (master mode)
    Property<0X40005800 + 0X10, 8, 8> SCLH;                 // SCL high period (master mode)
    Property<0X40005800 + 0X10, 16, 4> SDADEL;              // Data hold time
    Property<0X40005800 + 0X10, 20, 4> SCLDEL;              // Data setup time
    Property<0X40005800 + 0X10, 28, 4> PRESC;               // Timing prescaler
};


enum class I2C2_TIMEOUTR
{
    TIMEOUTA,                  // Bus timeout A
    TIDLE = 12,                // Idle clock timeout detection
    TIMOUTEN = 15,             // Clock timeout enable
    TIMEOUTB,                  // Bus timeout B
    TEXTEN = 31,               // Extended clock timeout enable
};

/*
    Status register 1 @ 0X40005800 + 0X14
*/
struct i2c2_timeoutr : public reg32bit<I2C2_TIMEOUTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005800 + 0X14, 0, 12> TIMEOUTA;            // Bus timeout A
    Property<0X40005800 + 0X14, 12, 1> TIDLE;               // Idle clock timeout detection
    Property<0X40005800 + 0X14, 15, 1> TIMOUTEN;            // Clock timeout enable
    Property<0X40005800 + 0X14, 16, 12> TIMEOUTB;           // Bus timeout B
    Property<0X40005800 + 0X14, 31, 1> TEXTEN;              // Extended clock timeout enable
};


enum class I2C2_ISR
{
    TXE,                       // Transmit data register empty (transmitters)
    TXIS,                      // Transmit interrupt status (transmitters)
    RXNE,                      // Receive data register not empty (receivers)
    ADDR,                      // Address matched (slave mode)
    NACKF,                     // Not acknowledge received flag
    STOPF,                     // Stop detection flag
    TC,                        // Transfer Complete (master mode)
    TCR,                       // Transfer Complete Reload
    BERR,                      // Bus error
    ARLO,                      // Arbitration lost
    OVR,                       // Overrun/Underrun (slave mode)
    PECERR,                    // PEC Error in reception
    TIMEOUT,                   // Timeout or t_low detection flag
    ALERT,                     // SMBus alert
    BUSY = 15,                 // Bus busy
    DIR,                       // Transfer direction (Slave mode)
    ADDCODE,                   // Address match code (Slave mode)
};

/*
    Interrupt and Status register @ 0X40005800 + 0X18
*/
struct i2c2_isr : public reg32bit<I2C2_ISR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005800 + 0X18, 0, 1> TXE;                  // Transmit data register empty (transmitters)
    Property<0X40005800 + 0X18, 1, 1> TXIS;                 // Transmit interrupt status (transmitters)
    Property<0X40005800 + 0X18, 2, 1> RXNE;                 // Receive data register not empty (receivers)
    Property<0X40005800 + 0X18, 3, 1> ADDR;                 // Address matched (slave mode)
    Property<0X40005800 + 0X18, 4, 1> NACKF;                // Not acknowledge received flag
    Property<0X40005800 + 0X18, 5, 1> STOPF;                // Stop detection flag
    Property<0X40005800 + 0X18, 6, 1> TC;                   // Transfer Complete (master mode)
    Property<0X40005800 + 0X18, 7, 1> TCR;                  // Transfer Complete Reload
    Property<0X40005800 + 0X18, 8, 1> BERR;                 // Bus error
    Property<0X40005800 + 0X18, 9, 1> ARLO;                 // Arbitration lost
    Property<0X40005800 + 0X18, 10, 1> OVR;                 // Overrun/Underrun (slave mode)
    Property<0X40005800 + 0X18, 11, 1> PECERR;              // PEC Error in reception
    Property<0X40005800 + 0X18, 12, 1> TIMEOUT;             // Timeout or t_low detection flag
    Property<0X40005800 + 0X18, 13, 1> ALERT;               // SMBus alert
    Property<0X40005800 + 0X18, 15, 1> BUSY;                // Bus busy
    Property<0X40005800 + 0X18, 16, 1> DIR;                 // Transfer direction (Slave mode)
    Property<0X40005800 + 0X18, 17, 7> ADDCODE;             // Address match code (Slave mode)
};


enum class I2C2_ICR
{
    ADDRCF = 3,                // Address Matched flag clear
    NACKCF,                    // Not Acknowledge flag clear
    STOPCF,                    // Stop detection flag clear
    BERRCF = 8,                // Bus error flag clear
    ARLOCF,                    // Arbitration lost flag clear
    OVRCF,                     // Overrun/Underrun flag clear
    PECCF,                     // PEC Error flag clear
    TIMOUTCF,                  // Timeout detection flag clear
    ALERTCF,                   // Alert flag clear
};

/*
    Interrupt clear register @ 0X40005800 + 0X1C
*/
struct i2c2_icr : public reg32bit<I2C2_ICR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40005800 + 0X1C, 3, 1> ADDRCF;               // Address Matched flag clear
    Property<0X40005800 + 0X1C, 4, 1> NACKCF;               // Not Acknowledge flag clear
    Property<0X40005800 + 0X1C, 5, 1> STOPCF;               // Stop detection flag clear
    Property<0X40005800 + 0X1C, 8, 1> BERRCF;               // Bus error flag clear
    Property<0X40005800 + 0X1C, 9, 1> ARLOCF;               // Arbitration lost flag clear
    Property<0X40005800 + 0X1C, 10, 1> OVRCF;               // Overrun/Underrun flag clear
    Property<0X40005800 + 0X1C, 11, 1> PECCF;               // PEC Error flag clear
    Property<0X40005800 + 0X1C, 12, 1> TIMOUTCF;            // Timeout detection flag clear
    Property<0X40005800 + 0X1C, 13, 1> ALERTCF;             // Alert flag clear
};


/*
    Inter-integrated circuit @ 0X40005800
*/
struct I2C2
{
    i2c2_cr1 CR1;              // Control register 1
    i2c2_cr2 CR2;              // Control register 2
    i2c2_oar1 OAR1;            // Own address register 1
    i2c2_oar2 OAR2;            // Own address register 2
    i2c2_timingr TIMINGR;      // Timing register
    i2c2_timeoutr TIMEOUTR;    // Status register 1
    i2c2_isr ISR;              // Interrupt and Status register
    i2c2_icr ICR;              // Interrupt clear register
    regrw PECR;                // PEC register
    regrw RXDR;                // Receive data register
    regrw TXDR;                // Transmit data register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40005800);}
};


enum class IWDG_SR
{
    PVU,                       // Watchdog prescaler value update
    RVU,                       // Watchdog counter reload value update
    WVU,                       // Watchdog counter window value update
};

/*
    Status register @ 0X40003000 + 0X0C
*/
struct iwdg_sr : public reg32bit<IWDG_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40003000 + 0X0C, 0, 1> PVU;                  // Watchdog prescaler value update
    Property<0X40003000 + 0X0C, 1, 1> RVU;                  // Watchdog counter reload value update
    Property<0X40003000 + 0X0C, 2, 1> WVU;                  // Watchdog counter window value update
};


/*
    Independent watchdog @ 0X40003000
*/
struct IWDG
{
    regrw KR;                  // Key register
    regrw PR;                  // Prescaler register
    regrw RLR;                 // Reload register
    iwdg_sr SR;                // Status register
    regrw WINR;                // Window register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40003000);}
};


enum class NVIC_IPR0
{
    PRI_00 = 6,                // PRI_00
    PRI_01 = 14,               // PRI_01
    PRI_02 = 22,               // PRI_02
    PRI_03 = 30,               // PRI_03
};

/*
    Interrupt Priority Register 0 @ 0XE000E100 + 0X0300
*/
struct nvic_ipr0 : public reg32bit<NVIC_IPR0>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0XE000E100 + 0X0300, 6, 2> PRI_00;             // PRI_00
    Property<0XE000E100 + 0X0300, 14, 2> PRI_01;            // PRI_01
    Property<0XE000E100 + 0X0300, 22, 2> PRI_02;            // PRI_02
    Property<0XE000E100 + 0X0300, 30, 2> PRI_03;            // PRI_03
};


enum class NVIC_IPR1
{
    PRI_40 = 6,                // PRI_40
    PRI_41 = 14,               // PRI_41
    PRI_42 = 22,               // PRI_42
    PRI_43 = 30,               // PRI_43
};

/*
    Interrupt Priority Register 1 @ 0XE000E100 + 0X0304
*/
struct nvic_ipr1 : public reg32bit<NVIC_IPR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0XE000E100 + 0X0304, 6, 2> PRI_40;             // PRI_40
    Property<0XE000E100 + 0X0304, 14, 2> PRI_41;            // PRI_41
    Property<0XE000E100 + 0X0304, 22, 2> PRI_42;            // PRI_42
    Property<0XE000E100 + 0X0304, 30, 2> PRI_43;            // PRI_43
};


enum class NVIC_IPR2
{
    PRI_80 = 6,                // PRI_80
    PRI_81 = 14,               // PRI_81
    PRI_82 = 22,               // PRI_82
    PRI_83 = 30,               // PRI_83
};

/*
    Interrupt Priority Register 2 @ 0XE000E100 + 0X0308
*/
struct nvic_ipr2 : public reg32bit<NVIC_IPR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0XE000E100 + 0X0308, 6, 2> PRI_80;             // PRI_80
    Property<0XE000E100 + 0X0308, 14, 2> PRI_81;            // PRI_81
    Property<0XE000E100 + 0X0308, 22, 2> PRI_82;            // PRI_82
    Property<0XE000E100 + 0X0308, 30, 2> PRI_83;            // PRI_83
};


enum class NVIC_IPR3
{
    PRI_120 = 6,               // PRI_120
    PRI_121 = 14,              // PRI_121
    PRI_122 = 22,              // PRI_122
    PRI_123 = 30,              // PRI_123
};

/*
    Interrupt Priority Register 3 @ 0XE000E100 + 0X030C
*/
struct nvic_ipr3 : public reg32bit<NVIC_IPR3>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0XE000E100 + 0X030C, 6, 2> PRI_120;            // PRI_120
    Property<0XE000E100 + 0X030C, 14, 2> PRI_121;           // PRI_121
    Property<0XE000E100 + 0X030C, 22, 2> PRI_122;           // PRI_122
    Property<0XE000E100 + 0X030C, 30, 2> PRI_123;           // PRI_123
};


enum class NVIC_IPR4
{
    PRI_160 = 6,               // PRI_160
    PRI_161 = 14,              // PRI_161
    PRI_162 = 22,              // PRI_162
    PRI_163 = 30,              // PRI_163
};

/*
    Interrupt Priority Register 4 @ 0XE000E100 + 0X0310
*/
struct nvic_ipr4 : public reg32bit<NVIC_IPR4>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0XE000E100 + 0X0310, 6, 2> PRI_160;            // PRI_160
    Property<0XE000E100 + 0X0310, 14, 2> PRI_161;           // PRI_161
    Property<0XE000E100 + 0X0310, 22, 2> PRI_162;           // PRI_162
    Property<0XE000E100 + 0X0310, 30, 2> PRI_163;           // PRI_163
};


enum class NVIC_IPR5
{
    PRI_200 = 6,               // PRI_200
    PRI_201 = 14,              // PRI_201
    PRI_202 = 22,              // PRI_202
    PRI_203 = 30,              // PRI_203
};

/*
    Interrupt Priority Register 5 @ 0XE000E100 + 0X0314
*/
struct nvic_ipr5 : public reg32bit<NVIC_IPR5>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0XE000E100 + 0X0314, 6, 2> PRI_200;            // PRI_200
    Property<0XE000E100 + 0X0314, 14, 2> PRI_201;           // PRI_201
    Property<0XE000E100 + 0X0314, 22, 2> PRI_202;           // PRI_202
    Property<0XE000E100 + 0X0314, 30, 2> PRI_203;           // PRI_203
};


enum class NVIC_IPR6
{
    PRI_240 = 6,               // PRI_240
    PRI_241 = 14,              // PRI_241
    PRI_242 = 22,              // PRI_242
    PRI_243 = 30,              // PRI_243
};

/*
    Interrupt Priority Register 6 @ 0XE000E100 + 0X0318
*/
struct nvic_ipr6 : public reg32bit<NVIC_IPR6>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0XE000E100 + 0X0318, 6, 2> PRI_240;            // PRI_240
    Property<0XE000E100 + 0X0318, 14, 2> PRI_241;           // PRI_241
    Property<0XE000E100 + 0X0318, 22, 2> PRI_242;           // PRI_242
    Property<0XE000E100 + 0X0318, 30, 2> PRI_243;           // PRI_243
};


enum class NVIC_IPR7
{
    PRI_280 = 6,               // PRI_280
    PRI_281 = 14,              // PRI_281
    PRI_282 = 22,              // PRI_282
    PRI_283 = 30,              // PRI_283
};

/*
    Interrupt Priority Register 7 @ 0XE000E100 + 0X031C
*/
struct nvic_ipr7 : public reg32bit<NVIC_IPR7>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0XE000E100 + 0X031C, 6, 2> PRI_280;            // PRI_280
    Property<0XE000E100 + 0X031C, 14, 2> PRI_281;           // PRI_281
    Property<0XE000E100 + 0X031C, 22, 2> PRI_282;           // PRI_282
    Property<0XE000E100 + 0X031C, 30, 2> PRI_283;           // PRI_283
};


/*
    Nested Vectored Interrupt Controller @ 0XE000E100
*/
struct NVIC
{
    regrw ISER;                // Interrupt Set Enable Register
    regrw ICER;                // Interrupt Clear Enable Register
    regrw ISPR;                // Interrupt Set-Pending Register
    regrw ICPR;                // Interrupt Clear-Pending Register
    nvic_ipr0 IPR0;            // Interrupt Priority Register 0
    nvic_ipr1 IPR1;            // Interrupt Priority Register 1
    nvic_ipr2 IPR2;            // Interrupt Priority Register 2
    nvic_ipr3 IPR3;            // Interrupt Priority Register 3
    nvic_ipr4 IPR4;            // Interrupt Priority Register 4
    nvic_ipr5 IPR5;            // Interrupt Priority Register 5
    nvic_ipr6 IPR6;            // Interrupt Priority Register 6
    nvic_ipr7 IPR7;            // Interrupt Priority Register 7

    void *operator new(size_t) {return reinterpret_cast<void *>(0XE000E100);}
};


enum class PWR_CR
{
    LPDS,                      // Low-power deep sleep
    PDDS,                      // Power down deepsleep
    CWUF,                      // Clear wakeup flag
    CSBF,                      // Clear standby flag
    PVDE,                      // Power voltage detector enable
    PLS,                       // PVD level selection
    DBP = 8,                   // Disable backup domain write protection
    FPDS,                      // Flash power down in Stop mode
};

/*
    power control register @ 0X40007000 + 0X00
*/
struct pwr_cr : public reg32bit<PWR_CR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40007000 + 0X00, 0, 1> LPDS;                 // Low-power deep sleep
    Property<0X40007000 + 0X00, 1, 1> PDDS;                 // Power down deepsleep
    Property<0X40007000 + 0X00, 2, 1> CWUF;                 // Clear wakeup flag
    Property<0X40007000 + 0X00, 3, 1> CSBF;                 // Clear standby flag
    Property<0X40007000 + 0X00, 4, 1> PVDE;                 // Power voltage detector enable
    Property<0X40007000 + 0X00, 5, 3> PLS;                  // PVD level selection
    Property<0X40007000 + 0X00, 8, 1> DBP;                  // Disable backup domain write protection
    Property<0X40007000 + 0X00, 9, 1> FPDS;                 // Flash power down in Stop mode
};


enum class PWR_CSR
{
    WUF,                       // Wakeup flag
    SBF,                       // Standby flag
    PVDO,                      // PVD output
    BRR,                       // Backup regulator ready
    EWUP = 8,                  // Enable WKUP pin
    BRE,                       // Backup regulator enable
};

/*
    power control/status register @ 0X40007000 + 0X04
*/
struct pwr_csr : public reg32bit<PWR_CSR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40007000 + 0X04, 0, 1> WUF;                  // Wakeup flag
    Property<0X40007000 + 0X04, 1, 1> SBF;                  // Standby flag
    Property<0X40007000 + 0X04, 2, 1> PVDO;                 // PVD output
    Property<0X40007000 + 0X04, 3, 1> BRR;                  // Backup regulator ready
    Property<0X40007000 + 0X04, 8, 1> EWUP;                 // Enable WKUP pin
    Property<0X40007000 + 0X04, 9, 1> BRE;                  // Backup regulator enable
};


/*
    Power control @ 0X40007000
*/
struct PWR
{
    pwr_cr CR;                 // power control register
    pwr_csr CSR;               // power control/status register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40007000);}
};


enum class RCC_CR
{
    HSION,                     // Internal High Speed clock enable
    HSIRDY,                    // Internal High Speed clock ready flag
    HSITRIM = 3,               // Internal High Speed clock trimming
    HSICAL = 8,                // Internal High Speed clock Calibration
    HSEON = 16,                // External High Speed clock enable
    HSERDY,                    // External High Speed clock ready flag
    HSEBYP,                    // External High Speed clock Bypass
    CSSON,                     // Clock Security System enable
    PLLON = 24,                // PLL enable
    PLLRDY,                    // PLL clock ready flag
};

/*
    Clock control register @ 0X40021000 + 0X00
*/
struct rcc_cr : public reg32bit<RCC_CR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X00, 0, 1> HSION;                // Internal High Speed clock enable
    Property<0X40021000 + 0X00, 1, 1> HSIRDY;               // Internal High Speed clock ready flag
    Property<0X40021000 + 0X00, 3, 5> HSITRIM;              // Internal High Speed clock trimming
    Property<0X40021000 + 0X00, 8, 8> HSICAL;               // Internal High Speed clock Calibration
    Property<0X40021000 + 0X00, 16, 1> HSEON;               // External High Speed clock enable
    Property<0X40021000 + 0X00, 17, 1> HSERDY;              // External High Speed clock ready flag
    Property<0X40021000 + 0X00, 18, 1> HSEBYP;              // External High Speed clock Bypass
    Property<0X40021000 + 0X00, 19, 1> CSSON;               // Clock Security System enable
    Property<0X40021000 + 0X00, 24, 1> PLLON;               // PLL enable
    Property<0X40021000 + 0X00, 25, 1> PLLRDY;              // PLL clock ready flag
};


enum class RCC_CFGR
{
    SW,                        // System clock Switch
    SWS = 2,                   // System Clock Switch Status
    HPRE = 4,                  // AHB prescaler
    PPRE = 8,                  // APB Low speed prescaler (APB1)
    ADCPRE = 14,               // ADC prescaler
    PLLSRC,                    // PLL input clock source
    PLLXTPRE = 17,             // HSE divider for PLL entry
    PLLMUL,                    // PLL Multiplication Factor
    MCO = 24,                  // Microcontroller clock output
    MCOPRE = 28,               // Microcontroller Clock Output Prescaler
    PLLNODIV = 31,             // PLL clock not divided for MCO
};

/*
    Clock configuration register (RCC_CFGR) @ 0X40021000 + 0X04
*/
struct rcc_cfgr : public reg32bit<RCC_CFGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X04, 0, 2> SW;                   // System clock Switch
    Property<0X40021000 + 0X04, 2, 2> SWS;                  // System Clock Switch Status
    Property<0X40021000 + 0X04, 4, 4> HPRE;                 // AHB prescaler
    Property<0X40021000 + 0X04, 8, 3> PPRE;                 // APB Low speed prescaler (APB1)
    Property<0X40021000 + 0X04, 14, 1> ADCPRE;              // ADC prescaler
    Property<0X40021000 + 0X04, 15, 2> PLLSRC;              // PLL input clock source
    Property<0X40021000 + 0X04, 17, 1> PLLXTPRE;            // HSE divider for PLL entry
    Property<0X40021000 + 0X04, 18, 4> PLLMUL;              // PLL Multiplication Factor
    Property<0X40021000 + 0X04, 24, 3> MCO;                 // Microcontroller clock output
    Property<0X40021000 + 0X04, 28, 3> MCOPRE;              // Microcontroller Clock Output Prescaler
    Property<0X40021000 + 0X04, 31, 1> PLLNODIV;            // PLL clock not divided for MCO
};


enum class RCC_CIR
{
    LSIRDYF,                   // LSI Ready Interrupt flag
    LSERDYF,                   // LSE Ready Interrupt flag
    HSIRDYF,                   // HSI Ready Interrupt flag
    HSERDYF,                   // HSE Ready Interrupt flag
    PLLRDYF,                   // PLL Ready Interrupt flag
    HSI14RDYF,                 // HSI14 ready interrupt flag
    HSI48RDYF,                 // HSI48 ready interrupt flag
    CSSF,                      // Clock Security System Interrupt flag
    LSIRDYIE,                  // LSI Ready Interrupt Enable
    LSERDYIE,                  // LSE Ready Interrupt Enable
    HSIRDYIE,                  // HSI Ready Interrupt Enable
    HSERDYIE,                  // HSE Ready Interrupt Enable
    PLLRDYIE,                  // PLL Ready Interrupt Enable
    HSI14RDYE,                 // HSI14 ready interrupt enable
    HSI48RDYIE,                // HSI48 ready interrupt enable
    LSIRDYC = 16,              // LSI Ready Interrupt Clear
    LSERDYC,                   // LSE Ready Interrupt Clear
    HSIRDYC,                   // HSI Ready Interrupt Clear
    HSERDYC,                   // HSE Ready Interrupt Clear
    PLLRDYC,                   // PLL Ready Interrupt Clear
    HSI14RDYC,                 // HSI 14 MHz Ready Interrupt Clear
    HSI48RDYC,                 // HSI48 Ready Interrupt Clear
    CSSC,                      // Clock security system interrupt clear
};

/*
    Clock interrupt register (RCC_CIR) @ 0X40021000 + 0X08
*/
struct rcc_cir : public reg32bit<RCC_CIR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X08, 0, 1> LSIRDYF;              // LSI Ready Interrupt flag
    Property<0X40021000 + 0X08, 1, 1> LSERDYF;              // LSE Ready Interrupt flag
    Property<0X40021000 + 0X08, 2, 1> HSIRDYF;              // HSI Ready Interrupt flag
    Property<0X40021000 + 0X08, 3, 1> HSERDYF;              // HSE Ready Interrupt flag
    Property<0X40021000 + 0X08, 4, 1> PLLRDYF;              // PLL Ready Interrupt flag
    Property<0X40021000 + 0X08, 5, 1> HSI14RDYF;            // HSI14 ready interrupt flag
    Property<0X40021000 + 0X08, 6, 1> HSI48RDYF;            // HSI48 ready interrupt flag
    Property<0X40021000 + 0X08, 7, 1> CSSF;                 // Clock Security System Interrupt flag
    Property<0X40021000 + 0X08, 8, 1> LSIRDYIE;             // LSI Ready Interrupt Enable
    Property<0X40021000 + 0X08, 9, 1> LSERDYIE;             // LSE Ready Interrupt Enable
    Property<0X40021000 + 0X08, 10, 1> HSIRDYIE;            // HSI Ready Interrupt Enable
    Property<0X40021000 + 0X08, 11, 1> HSERDYIE;            // HSE Ready Interrupt Enable
    Property<0X40021000 + 0X08, 12, 1> PLLRDYIE;            // PLL Ready Interrupt Enable
    Property<0X40021000 + 0X08, 13, 1> HSI14RDYE;           // HSI14 ready interrupt enable
    Property<0X40021000 + 0X08, 14, 1> HSI48RDYIE;          // HSI48 ready interrupt enable
    Property<0X40021000 + 0X08, 16, 1> LSIRDYC;             // LSI Ready Interrupt Clear
    Property<0X40021000 + 0X08, 17, 1> LSERDYC;             // LSE Ready Interrupt Clear
    Property<0X40021000 + 0X08, 18, 1> HSIRDYC;             // HSI Ready Interrupt Clear
    Property<0X40021000 + 0X08, 19, 1> HSERDYC;             // HSE Ready Interrupt Clear
    Property<0X40021000 + 0X08, 20, 1> PLLRDYC;             // PLL Ready Interrupt Clear
    Property<0X40021000 + 0X08, 21, 1> HSI14RDYC;           // HSI 14 MHz Ready Interrupt Clear
    Property<0X40021000 + 0X08, 22, 1> HSI48RDYC;           // HSI48 Ready Interrupt Clear
    Property<0X40021000 + 0X08, 23, 1> CSSC;                // Clock security system interrupt clear
};


enum class RCC_APB2RSTR
{
    SYSCFGRST,                 // SYSCFG and COMP reset
    ADCRST = 9,                // ADC interface reset
    TIM1RST = 11,              // TIM1 timer reset
    SPI1RST,                   // SPI 1 reset
    USART1RST = 14,            // USART1 reset
    TIM15RST = 16,             // TIM15 timer reset
    TIM16RST,                  // TIM16 timer reset
    TIM17RST,                  // TIM17 timer reset
    DBGMCURST = 22,            // Debug MCU reset
};

/*
    APB2 peripheral reset register (RCC_APB2RSTR) @ 0X40021000 + 0X0C
*/
struct rcc_apb2rstr : public reg32bit<RCC_APB2RSTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X0C, 0, 1> SYSCFGRST;            // SYSCFG and COMP reset
    Property<0X40021000 + 0X0C, 9, 1> ADCRST;               // ADC interface reset
    Property<0X40021000 + 0X0C, 11, 1> TIM1RST;             // TIM1 timer reset
    Property<0X40021000 + 0X0C, 12, 1> SPI1RST;             // SPI 1 reset
    Property<0X40021000 + 0X0C, 14, 1> USART1RST;           // USART1 reset
    Property<0X40021000 + 0X0C, 16, 1> TIM15RST;            // TIM15 timer reset
    Property<0X40021000 + 0X0C, 17, 1> TIM16RST;            // TIM16 timer reset
    Property<0X40021000 + 0X0C, 18, 1> TIM17RST;            // TIM17 timer reset
    Property<0X40021000 + 0X0C, 22, 1> DBGMCURST;           // Debug MCU reset
};


enum class RCC_APB1RSTR
{
    TIM3RST = 1,               // Timer 3 reset
    TIM6RST = 4,               // Timer 6 reset
    TIM14RST = 8,              // Timer 14 reset
    WWDGRST = 11,              // Window watchdog reset
    SPI2RST = 14,              // SPI2 reset
    USART2RST = 17,            // USART 2 reset
    I2C1RST = 21,              // I2C1 reset
    I2C2RST,                   // I2C2 reset
    PWRRST = 28,               // Power interface reset
};

/*
    APB1 peripheral reset register (RCC_APB1RSTR) @ 0X40021000 + 0X10
*/
struct rcc_apb1rstr : public reg32bit<RCC_APB1RSTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X10, 1, 1> TIM3RST;              // Timer 3 reset
    Property<0X40021000 + 0X10, 4, 1> TIM6RST;              // Timer 6 reset
    Property<0X40021000 + 0X10, 8, 1> TIM14RST;             // Timer 14 reset
    Property<0X40021000 + 0X10, 11, 1> WWDGRST;             // Window watchdog reset
    Property<0X40021000 + 0X10, 14, 1> SPI2RST;             // SPI2 reset
    Property<0X40021000 + 0X10, 17, 1> USART2RST;           // USART 2 reset
    Property<0X40021000 + 0X10, 21, 1> I2C1RST;             // I2C1 reset
    Property<0X40021000 + 0X10, 22, 1> I2C2RST;             // I2C2 reset
    Property<0X40021000 + 0X10, 28, 1> PWRRST;              // Power interface reset
};


enum class RCC_AHBENR
{
    DMAEN,                     // DMA1 clock enable
    SRAMEN = 2,                // SRAM interface clock enable
    FLITFEN = 4,               // FLITF clock enable
    CRCEN = 6,                 // CRC clock enable
    IOPAEN = 17,               // I/O port A clock enable
    IOPBEN,                    // I/O port B clock enable
    IOPCEN,                    // I/O port C clock enable
    IOPDEN,                    // I/O port D clock enable
    IOPFEN = 22,               // I/O port F clock enable
};

/*
    AHB Peripheral Clock enable register (RCC_AHBENR) @ 0X40021000 + 0X14
*/
struct rcc_ahbenr : public reg32bit<RCC_AHBENR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X14, 0, 1> DMAEN;                // DMA1 clock enable
    Property<0X40021000 + 0X14, 2, 1> SRAMEN;               // SRAM interface clock enable
    Property<0X40021000 + 0X14, 4, 1> FLITFEN;              // FLITF clock enable
    Property<0X40021000 + 0X14, 6, 1> CRCEN;                // CRC clock enable
    Property<0X40021000 + 0X14, 17, 1> IOPAEN;              // I/O port A clock enable
    Property<0X40021000 + 0X14, 18, 1> IOPBEN;              // I/O port B clock enable
    Property<0X40021000 + 0X14, 19, 1> IOPCEN;              // I/O port C clock enable
    Property<0X40021000 + 0X14, 20, 1> IOPDEN;              // I/O port D clock enable
    Property<0X40021000 + 0X14, 22, 1> IOPFEN;              // I/O port F clock enable
};


enum class RCC_APB2ENR
{
    SYSCFGEN,                  // SYSCFG clock enable
    ADCEN = 9,                 // ADC 1 interface clock enable
    TIM1EN = 11,               // TIM1 Timer clock enable
    SPI1EN,                    // SPI 1 clock enable
    USART1EN = 14,             // USART1 clock enable
    TIM15EN = 16,              // TIM15 timer clock enable
    TIM16EN,                   // TIM16 timer clock enable
    TIM17EN,                   // TIM17 timer clock enable
    DBGMCUEN = 22,             // MCU debug module clock enable
};

/*
    APB2 peripheral clock enable register (RCC_APB2ENR) @ 0X40021000 + 0X18
*/
struct rcc_apb2enr : public reg32bit<RCC_APB2ENR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X18, 0, 1> SYSCFGEN;             // SYSCFG clock enable
    Property<0X40021000 + 0X18, 9, 1> ADCEN;                // ADC 1 interface clock enable
    Property<0X40021000 + 0X18, 11, 1> TIM1EN;              // TIM1 Timer clock enable
    Property<0X40021000 + 0X18, 12, 1> SPI1EN;              // SPI 1 clock enable
    Property<0X40021000 + 0X18, 14, 1> USART1EN;            // USART1 clock enable
    Property<0X40021000 + 0X18, 16, 1> TIM15EN;             // TIM15 timer clock enable
    Property<0X40021000 + 0X18, 17, 1> TIM16EN;             // TIM16 timer clock enable
    Property<0X40021000 + 0X18, 18, 1> TIM17EN;             // TIM17 timer clock enable
    Property<0X40021000 + 0X18, 22, 1> DBGMCUEN;            // MCU debug module clock enable
};


enum class RCC_APB1ENR
{
    TIM3EN = 1,                // Timer 3 clock enable
    TIM6EN = 4,                // Timer 6 clock enable
    TIM14EN = 8,               // Timer 14 clock enable
    WWDGEN = 11,               // Window watchdog clock enable
    SPI2EN = 14,               // SPI 2 clock enable
    USART2EN = 17,             // USART 2 clock enable
    I2C1EN = 21,               // I2C 1 clock enable
    I2C2EN,                    // I2C 2 clock enable
    PWREN = 28,                // Power interface clock enable
};

/*
    APB1 peripheral clock enable register (RCC_APB1ENR) @ 0X40021000 + 0X1C
*/
struct rcc_apb1enr : public reg32bit<RCC_APB1ENR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X1C, 1, 1> TIM3EN;               // Timer 3 clock enable
    Property<0X40021000 + 0X1C, 4, 1> TIM6EN;               // Timer 6 clock enable
    Property<0X40021000 + 0X1C, 8, 1> TIM14EN;              // Timer 14 clock enable
    Property<0X40021000 + 0X1C, 11, 1> WWDGEN;              // Window watchdog clock enable
    Property<0X40021000 + 0X1C, 14, 1> SPI2EN;              // SPI 2 clock enable
    Property<0X40021000 + 0X1C, 17, 1> USART2EN;            // USART 2 clock enable
    Property<0X40021000 + 0X1C, 21, 1> I2C1EN;              // I2C 1 clock enable
    Property<0X40021000 + 0X1C, 22, 1> I2C2EN;              // I2C 2 clock enable
    Property<0X40021000 + 0X1C, 28, 1> PWREN;               // Power interface clock enable
};


enum class RCC_BDCR
{
    LSEON,                     // External Low Speed oscillator enable
    LSERDY,                    // External Low Speed oscillator ready
    LSEBYP,                    // External Low Speed oscillator bypass
    LSEDRV,                    // LSE oscillator drive capability
    RTCSEL = 8,                // RTC clock source selection
    RTCEN = 15,                // RTC clock enable
    BDRST,                     // Backup domain software reset
};

/*
    Backup domain control register (RCC_BDCR) @ 0X40021000 + 0X20
*/
struct rcc_bdcr : public reg32bit<RCC_BDCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X20, 0, 1> LSEON;                // External Low Speed oscillator enable
    Property<0X40021000 + 0X20, 1, 1> LSERDY;               // External Low Speed oscillator ready
    Property<0X40021000 + 0X20, 2, 1> LSEBYP;               // External Low Speed oscillator bypass
    Property<0X40021000 + 0X20, 3, 2> LSEDRV;               // LSE oscillator drive capability
    Property<0X40021000 + 0X20, 8, 2> RTCSEL;               // RTC clock source selection
    Property<0X40021000 + 0X20, 15, 1> RTCEN;               // RTC clock enable
    Property<0X40021000 + 0X20, 16, 1> BDRST;               // Backup domain software reset
};


enum class RCC_CSR
{
    LSION,                     // Internal low speed oscillator enable
    LSIRDY,                    // Internal low speed oscillator ready
    RMVF = 24,                 // Remove reset flag
    OBLRSTF,                   // Option byte loader reset flag
    PINRSTF,                   // PIN reset flag
    PORRSTF,                   // POR/PDR reset flag
    SFTRSTF,                   // Software reset flag
    IWDGRSTF,                  // Independent watchdog reset flag
    WWDGRSTF,                  // Window watchdog reset flag
    LPWRRSTF,                  // Low-power reset flag
};

/*
    Control/status register (RCC_CSR) @ 0X40021000 + 0X24
*/
struct rcc_csr : public reg32bit<RCC_CSR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X24, 0, 1> LSION;                // Internal low speed oscillator enable
    Property<0X40021000 + 0X24, 1, 1> LSIRDY;               // Internal low speed oscillator ready
    Property<0X40021000 + 0X24, 24, 1> RMVF;                // Remove reset flag
    Property<0X40021000 + 0X24, 25, 1> OBLRSTF;             // Option byte loader reset flag
    Property<0X40021000 + 0X24, 26, 1> PINRSTF;             // PIN reset flag
    Property<0X40021000 + 0X24, 27, 1> PORRSTF;             // POR/PDR reset flag
    Property<0X40021000 + 0X24, 28, 1> SFTRSTF;             // Software reset flag
    Property<0X40021000 + 0X24, 29, 1> IWDGRSTF;            // Independent watchdog reset flag
    Property<0X40021000 + 0X24, 30, 1> WWDGRSTF;            // Window watchdog reset flag
    Property<0X40021000 + 0X24, 31, 1> LPWRRSTF;            // Low-power reset flag
};


enum class RCC_AHBRSTR
{
    IOPARST = 17,              // I/O port A reset
    IOPBRST,                   // I/O port B reset
    IOPCRST,                   // I/O port C reset
    IOPDRST,                   // I/O port D reset
    IOPFRST = 22,              // I/O port F reset
};

/*
    AHB peripheral reset register @ 0X40021000 + 0X28
*/
struct rcc_ahbrstr : public reg32bit<RCC_AHBRSTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X28, 17, 1> IOPARST;             // I/O port A reset
    Property<0X40021000 + 0X28, 18, 1> IOPBRST;             // I/O port B reset
    Property<0X40021000 + 0X28, 19, 1> IOPCRST;             // I/O port C reset
    Property<0X40021000 + 0X28, 20, 1> IOPDRST;             // I/O port D reset
    Property<0X40021000 + 0X28, 22, 1> IOPFRST;             // I/O port F reset
};


enum class RCC_CFGR3
{
    USART1SW,                  // USART1 clock source selection
    I2C1SW = 4,                // I2C1 clock source selection
    ADCSW = 8,                 // ADC clock source selection
    USART2SW = 16,             // USART2 clock source selection
};

/*
    Clock configuration register 3 @ 0X40021000 + 0X30
*/
struct rcc_cfgr3 : public reg32bit<RCC_CFGR3>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X30, 0, 2> USART1SW;             // USART1 clock source selection
    Property<0X40021000 + 0X30, 4, 1> I2C1SW;               // I2C1 clock source selection
    Property<0X40021000 + 0X30, 8, 1> ADCSW;                // ADC clock source selection
    Property<0X40021000 + 0X30, 16, 2> USART2SW;            // USART2 clock source selection
};


enum class RCC_CR2
{
    HSI14ON,                   // HSI14 clock enable
    HSI14RDY,                  // HR14 clock ready flag
    HSI14DIS,                  // HSI14 clock request from ADC disable
    HSI14TRIM,                 // HSI14 clock trimming
    HSI14CAL = 8,              // HSI14 clock calibration
    HSI48ON = 16,              // HSI48 clock enable
    HSI48RDY,                  // HSI48 clock ready flag
    HSI48CAL = 24,             // HSI48 factory clock calibration
};

/*
    Clock control register 2 @ 0X40021000 + 0X34
*/
struct rcc_cr2 : public reg32bit<RCC_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40021000 + 0X34, 0, 1> HSI14ON;              // HSI14 clock enable
    Property<0X40021000 + 0X34, 1, 1> HSI14RDY;             // HR14 clock ready flag
    Property<0X40021000 + 0X34, 2, 1> HSI14DIS;             // HSI14 clock request from ADC disable
    Property<0X40021000 + 0X34, 3, 5> HSI14TRIM;            // HSI14 clock trimming
    Property<0X40021000 + 0X34, 8, 8> HSI14CAL;             // HSI14 clock calibration
    Property<0X40021000 + 0X34, 16, 1> HSI48ON;             // HSI48 clock enable
    Property<0X40021000 + 0X34, 17, 1> HSI48RDY;            // HSI48 clock ready flag
    Property<0X40021000 + 0X34, 24, 1> HSI48CAL;            // HSI48 factory clock calibration
};


/*
    Reset and clock control @ 0X40021000
*/
struct RCC
{
    rcc_cr CR;                 // Clock control register
    rcc_cfgr CFGR;             // Clock configuration register (RCC_CFGR)
    rcc_cir CIR;               // Clock interrupt register (RCC_CIR)
    rcc_apb2rstr APB2RSTR;     // APB2 peripheral reset register (RCC_APB2RSTR)
    rcc_apb1rstr APB1RSTR;     // APB1 peripheral reset register (RCC_APB1RSTR)
    rcc_ahbenr AHBENR;         // AHB Peripheral Clock enable register (RCC_AHBENR)
    rcc_apb2enr APB2ENR;       // APB2 peripheral clock enable register (RCC_APB2ENR)
    rcc_apb1enr APB1ENR;       // APB1 peripheral clock enable register (RCC_APB1ENR)
    rcc_bdcr BDCR;             // Backup domain control register (RCC_BDCR)
    rcc_csr CSR;               // Control/status register (RCC_CSR)
    rcc_ahbrstr AHBRSTR;       // AHB peripheral reset register
    regrw CFGR2;               // Clock configuration register 2
    rcc_cfgr3 CFGR3;           // Clock configuration register 3
    rcc_cr2 CR2;               // Clock control register 2

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40021000);}
};


enum class RTC_TR
{
    SU,                        // Second units in BCD format
    ST = 4,                    // Second tens in BCD format
    MNU = 8,                   // Minute units in BCD format
    MNT = 12,                  // Minute tens in BCD format
    HU = 16,                   // Hour units in BCD format
    HT = 20,                   // Hour tens in BCD format
    PM = 22,                   // AM/PM notation
};

/*
    time register @ 0X40002800 + 0X00
*/
struct rtc_tr : public reg32bit<RTC_TR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X00, 0, 4> SU;                   // Second units in BCD format
    Property<0X40002800 + 0X00, 4, 3> ST;                   // Second tens in BCD format
    Property<0X40002800 + 0X00, 8, 4> MNU;                  // Minute units in BCD format
    Property<0X40002800 + 0X00, 12, 3> MNT;                 // Minute tens in BCD format
    Property<0X40002800 + 0X00, 16, 4> HU;                  // Hour units in BCD format
    Property<0X40002800 + 0X00, 20, 2> HT;                  // Hour tens in BCD format
    Property<0X40002800 + 0X00, 22, 1> PM;                  // AM/PM notation
};


enum class RTC_DR
{
    DU,                        // Date units in BCD format
    DT = 4,                    // Date tens in BCD format
    MU = 8,                    // Month units in BCD format
    MT = 12,                   // Month tens in BCD format
    WDU,                       // Week day units
    YU = 16,                   // Year units in BCD format
    YT = 20,                   // Year tens in BCD format
};

/*
    date register @ 0X40002800 + 0X04
*/
struct rtc_dr : public reg32bit<RTC_DR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X04, 0, 4> DU;                   // Date units in BCD format
    Property<0X40002800 + 0X04, 4, 2> DT;                   // Date tens in BCD format
    Property<0X40002800 + 0X04, 8, 4> MU;                   // Month units in BCD format
    Property<0X40002800 + 0X04, 12, 1> MT;                  // Month tens in BCD format
    Property<0X40002800 + 0X04, 13, 3> WDU;                 // Week day units
    Property<0X40002800 + 0X04, 16, 4> YU;                  // Year units in BCD format
    Property<0X40002800 + 0X04, 20, 4> YT;                  // Year tens in BCD format
};


enum class RTC_CR
{
    TSEDGE = 3,                // Time-stamp event active edge
    REFCKON,                   // RTC_REFIN reference clock detection enable (50 or 60 Hz)
    BYPSHAD,                   // Bypass the shadow registers
    FMT,                       // Hour format
    ALRAE = 8,                 // Alarm A enable
    TSE = 11,                  // timestamp enable
    ALRAIE,                    // Alarm A interrupt enable
    TSIE = 15,                 // Time-stamp interrupt enable
    ADD1H,                     // Add 1 hour (summer time change)
    SUB1H,                     // Subtract 1 hour (winter time change)
    BKP,                       // Backup
    COSEL,                     // Calibration output selection
    POL,                       // Output polarity
    OSEL,                      // Output selection
    COE = 23,                  // Calibration output enable
};

/*
    control register @ 0X40002800 + 0X08
*/
struct rtc_cr : public reg32bit<RTC_CR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X08, 3, 1> TSEDGE;               // Time-stamp event active edge
    Property<0X40002800 + 0X08, 4, 1> REFCKON;              // RTC_REFIN reference clock detection enable (50 or 60 Hz)
    Property<0X40002800 + 0X08, 5, 1> BYPSHAD;              // Bypass the shadow registers
    Property<0X40002800 + 0X08, 6, 1> FMT;                  // Hour format
    Property<0X40002800 + 0X08, 8, 1> ALRAE;                // Alarm A enable
    Property<0X40002800 + 0X08, 11, 1> TSE;                 // timestamp enable
    Property<0X40002800 + 0X08, 12, 1> ALRAIE;              // Alarm A interrupt enable
    Property<0X40002800 + 0X08, 15, 1> TSIE;                // Time-stamp interrupt enable
    Property<0X40002800 + 0X08, 16, 1> ADD1H;               // Add 1 hour (summer time change)
    Property<0X40002800 + 0X08, 17, 1> SUB1H;               // Subtract 1 hour (winter time change)
    Property<0X40002800 + 0X08, 18, 1> BKP;                 // Backup
    Property<0X40002800 + 0X08, 19, 1> COSEL;               // Calibration output selection
    Property<0X40002800 + 0X08, 20, 1> POL;                 // Output polarity
    Property<0X40002800 + 0X08, 21, 2> OSEL;                // Output selection
    Property<0X40002800 + 0X08, 23, 1> COE;                 // Calibration output enable
};


enum class RTC_ISR
{
    ALRAWF,                    // Alarm A write flag
    SHPF = 3,                  // Shift operation pending
    INITS,                     // Initialization status flag
    RSF,                       // Registers synchronization flag
    INITF,                     // Initialization flag
    INIT,                      // Initialization mode
    ALRAF,                     // Alarm A flag
    TSF = 11,                  // Time-stamp flag
    TSOVF,                     // Time-stamp overflow flag
    TAMP1F,                    // RTC_TAMP1 detection flag
    TAMP2F,                    // RTC_TAMP2 detection flag
    RECALPF = 16,              // Recalibration pending Flag
};

/*
    initialization and status register @ 0X40002800 + 0X0C
*/
struct rtc_isr : public reg32bit<RTC_ISR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X0C, 0, 1> ALRAWF;               // Alarm A write flag
    Property<0X40002800 + 0X0C, 3, 1> SHPF;                 // Shift operation pending
    Property<0X40002800 + 0X0C, 4, 1> INITS;                // Initialization status flag
    Property<0X40002800 + 0X0C, 5, 1> RSF;                  // Registers synchronization flag
    Property<0X40002800 + 0X0C, 6, 1> INITF;                // Initialization flag
    Property<0X40002800 + 0X0C, 7, 1> INIT;                 // Initialization mode
    Property<0X40002800 + 0X0C, 8, 1> ALRAF;                // Alarm A flag
    Property<0X40002800 + 0X0C, 11, 1> TSF;                 // Time-stamp flag
    Property<0X40002800 + 0X0C, 12, 1> TSOVF;               // Time-stamp overflow flag
    Property<0X40002800 + 0X0C, 13, 1> TAMP1F;              // RTC_TAMP1 detection flag
    Property<0X40002800 + 0X0C, 14, 1> TAMP2F;              // RTC_TAMP2 detection flag
    Property<0X40002800 + 0X0C, 16, 1> RECALPF;             // Recalibration pending Flag
};


enum class RTC_PRER
{
    PREDIV_S,                  // Synchronous prescaler factor
    PREDIV_A = 16,             // Asynchronous prescaler factor
};

/*
    prescaler register @ 0X40002800 + 0X10
*/
struct rtc_prer : public reg32bit<RTC_PRER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X10, 0, 15> PREDIV_S;            // Synchronous prescaler factor
    Property<0X40002800 + 0X10, 16, 7> PREDIV_A;            // Asynchronous prescaler factor
};


enum class RTC_ALRMAR
{
    SU,                        // Second units in BCD format.
    ST = 4,                    // Second tens in BCD format.
    MSK1 = 7,                  // Alarm A seconds mask
    MNU,                       // Minute units in BCD format.
    MNT = 12,                  // Minute tens in BCD format.
    MSK2 = 15,                 // Alarm A minutes mask
    HU,                        // Hour units in BCD format.
    HT = 20,                   // Hour tens in BCD format.
    PM = 22,                   // AM/PM notation
    MSK3,                      // Alarm A hours mask
    DU,                        // Date units or day in BCD format.
    DT = 28,                   // Date tens in BCD format.
    WDSEL = 30,                // Week day selection
    MSK4,                      // Alarm A date mask
};

/*
    alarm A register @ 0X40002800 + 0X1C
*/
struct rtc_alrmar : public reg32bit<RTC_ALRMAR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X1C, 0, 4> SU;                   // Second units in BCD format.
    Property<0X40002800 + 0X1C, 4, 3> ST;                   // Second tens in BCD format.
    Property<0X40002800 + 0X1C, 7, 1> MSK1;                 // Alarm A seconds mask
    Property<0X40002800 + 0X1C, 8, 4> MNU;                  // Minute units in BCD format.
    Property<0X40002800 + 0X1C, 12, 3> MNT;                 // Minute tens in BCD format.
    Property<0X40002800 + 0X1C, 15, 1> MSK2;                // Alarm A minutes mask
    Property<0X40002800 + 0X1C, 16, 4> HU;                  // Hour units in BCD format.
    Property<0X40002800 + 0X1C, 20, 2> HT;                  // Hour tens in BCD format.
    Property<0X40002800 + 0X1C, 22, 1> PM;                  // AM/PM notation
    Property<0X40002800 + 0X1C, 23, 1> MSK3;                // Alarm A hours mask
    Property<0X40002800 + 0X1C, 24, 4> DU;                  // Date units or day in BCD format.
    Property<0X40002800 + 0X1C, 28, 2> DT;                  // Date tens in BCD format.
    Property<0X40002800 + 0X1C, 30, 1> WDSEL;               // Week day selection
    Property<0X40002800 + 0X1C, 31, 1> MSK4;                // Alarm A date mask
};


enum class RTC_SHIFTR
{
    SUBFS,                     // Subtract a fraction of a second
    ADD1S = 31,                // Reserved
};

/*
    shift control register @ 0X40002800 + 0X2C
*/
struct rtc_shiftr : public reg32bit<RTC_SHIFTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X2C, 0, 15> SUBFS;               // Subtract a fraction of a second
    Property<0X40002800 + 0X2C, 31, 1> ADD1S;               // Reserved
};


enum class RTC_TSTR
{
    SU,                        // Second units in BCD format.
    ST = 4,                    // Second tens in BCD format.
    MNU = 8,                   // Minute units in BCD format.
    MNT = 12,                  // Minute tens in BCD format.
    HU = 16,                   // Hour units in BCD format.
    HT = 20,                   // Hour tens in BCD format.
    PM = 22,                   // AM/PM notation
};

/*
    timestamp time register @ 0X40002800 + 0X30
*/
struct rtc_tstr : public reg32bit<RTC_TSTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X30, 0, 4> SU;                   // Second units in BCD format.
    Property<0X40002800 + 0X30, 4, 3> ST;                   // Second tens in BCD format.
    Property<0X40002800 + 0X30, 8, 4> MNU;                  // Minute units in BCD format.
    Property<0X40002800 + 0X30, 12, 3> MNT;                 // Minute tens in BCD format.
    Property<0X40002800 + 0X30, 16, 4> HU;                  // Hour units in BCD format.
    Property<0X40002800 + 0X30, 20, 2> HT;                  // Hour tens in BCD format.
    Property<0X40002800 + 0X30, 22, 1> PM;                  // AM/PM notation
};


enum class RTC_TSDR
{
    DU,                        // Date units in BCD format
    DT = 4,                    // Date tens in BCD format
    MU = 8,                    // Month units in BCD format
    MT = 12,                   // Month tens in BCD format
    WDU,                       // Week day units
};

/*
    timestamp date register @ 0X40002800 + 0X34
*/
struct rtc_tsdr : public reg32bit<RTC_TSDR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X34, 0, 4> DU;                   // Date units in BCD format
    Property<0X40002800 + 0X34, 4, 2> DT;                   // Date tens in BCD format
    Property<0X40002800 + 0X34, 8, 4> MU;                   // Month units in BCD format
    Property<0X40002800 + 0X34, 12, 1> MT;                  // Month tens in BCD format
    Property<0X40002800 + 0X34, 13, 3> WDU;                 // Week day units
};


enum class RTC_CALR
{
    CALM,                      // Calibration minus
    CALW16 = 13,               // Reserved
    CALW8,                     // Use a 16-second calibration cycle period
    CALP,                      // Use an 8-second calibration cycle period
};

/*
    calibration register @ 0X40002800 + 0X3C
*/
struct rtc_calr : public reg32bit<RTC_CALR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X3C, 0, 9> CALM;                 // Calibration minus
    Property<0X40002800 + 0X3C, 13, 1> CALW16;              // Reserved
    Property<0X40002800 + 0X3C, 14, 1> CALW8;               // Use a 16-second calibration cycle period
    Property<0X40002800 + 0X3C, 15, 1> CALP;                // Use an 8-second calibration cycle period
};


enum class RTC_TAFCR
{
    TAMP1E,                    // RTC_TAMP1 input detection enable
    TAMP1TRG,                  // Active level for RTC_TAMP1 input
    TAMPIE,                    // Tamper interrupt enable
    TAMP2E,                    // RTC_TAMP2 input detection enable
    TAMP2_TRG,                 // Active level for RTC_TAMP2 input
    TAMPTS = 7,                // Activate timestamp on tamper detection event
    TAMPFREQ,                  // Tamper sampling frequency
    TAMPFLT = 11,              // RTC_TAMPx filter count
    TAMP_PRCH = 13,            // RTC_TAMPx precharge duration
    TAMP_PUDIS = 15,           // RTC_TAMPx pull-up disable
    PC13VALUE = 18,            // RTC_ALARM output type/PC13 value
    PC13MODE,                  // PC13 mode
    PC14VALUE,                 // PC14 value
    PC14MODE,                  // PC14 mode
    PC15VALUE,                 // PC15 value
    PC15MODE,                  // PC15 mode
};

/*
    tamper and alternate function configuration register @ 0X40002800 + 0X40
*/
struct rtc_tafcr : public reg32bit<RTC_TAFCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X40, 0, 1> TAMP1E;               // RTC_TAMP1 input detection enable
    Property<0X40002800 + 0X40, 1, 1> TAMP1TRG;             // Active level for RTC_TAMP1 input
    Property<0X40002800 + 0X40, 2, 1> TAMPIE;               // Tamper interrupt enable
    Property<0X40002800 + 0X40, 3, 1> TAMP2E;               // RTC_TAMP2 input detection enable
    Property<0X40002800 + 0X40, 4, 1> TAMP2_TRG;            // Active level for RTC_TAMP2 input
    Property<0X40002800 + 0X40, 7, 1> TAMPTS;               // Activate timestamp on tamper detection event
    Property<0X40002800 + 0X40, 8, 3> TAMPFREQ;             // Tamper sampling frequency
    Property<0X40002800 + 0X40, 11, 2> TAMPFLT;             // RTC_TAMPx filter count
    Property<0X40002800 + 0X40, 13, 2> TAMP_PRCH;           // RTC_TAMPx precharge duration
    Property<0X40002800 + 0X40, 15, 1> TAMP_PUDIS;          // RTC_TAMPx pull-up disable
    Property<0X40002800 + 0X40, 18, 1> PC13VALUE;           // RTC_ALARM output type/PC13 value
    Property<0X40002800 + 0X40, 19, 1> PC13MODE;            // PC13 mode
    Property<0X40002800 + 0X40, 20, 1> PC14VALUE;           // PC14 value
    Property<0X40002800 + 0X40, 21, 1> PC14MODE;            // PC14 mode
    Property<0X40002800 + 0X40, 22, 1> PC15VALUE;           // PC15 value
    Property<0X40002800 + 0X40, 23, 1> PC15MODE;            // PC15 mode
};


enum class RTC_ALRMASSR
{
    SS,                        // Sub seconds value
    MASKSS = 24,               // Mask the most-significant bits starting at this bit
};

/*
    alarm A sub second register @ 0X40002800 + 0X44
*/
struct rtc_alrmassr : public reg32bit<RTC_ALRMASSR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002800 + 0X44, 0, 15> SS;                  // Sub seconds value
    Property<0X40002800 + 0X44, 24, 4> MASKSS;              // Mask the most-significant bits starting at this bit
};


/*
    Real-time clock @ 0X40002800
*/
struct RTC
{
    rtc_tr TR;                 // time register
    rtc_dr DR;                 // date register
    rtc_cr CR;                 // control register
    rtc_isr ISR;               // initialization and status register
    rtc_prer PRER;             // prescaler register
    rtc_alrmar ALRMAR;         // alarm A register
    regrw WPR;                 // write protection register
    regrw SSR;                 // sub second register
    rtc_shiftr SHIFTR;         // shift control register
    rtc_tstr TSTR;             // timestamp time register
    rtc_tsdr TSDR;             // timestamp date register
    regrw TSSSR;               // time-stamp sub second register
    rtc_calr CALR;             // calibration register
    rtc_tafcr TAFCR;           // tamper and alternate function configuration register
    rtc_alrmassr ALRMASSR;     // alarm A sub second register
    regrw BKP0R;               // backup register
    regrw BKP1R;               // backup register
    regrw BKP2R;               // backup register
    regrw BKP3R;               // backup register
    regrw BKP4R;               // backup register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40002800);}
};


enum class SPI1_CR1
{
    CPHA,                      // Clock phase
    CPOL,                      // Clock polarity
    MSTR,                      // Master selection
    BR,                        // Baud rate control
    SPE = 6,                   // SPI enable
    LSBFIRST,                  // Frame format
    SSI,                       // Internal slave select
    SSM,                       // Software slave management
    RXONLY,                    // Receive only
    DFF,                       // Data frame format
    CRCNEXT,                   // CRC transfer next
    CRCEN,                     // Hardware CRC calculation enable
    BIDIOE,                    // Output enable in bidirectional mode
    BIDIMODE,                  // Bidirectional data mode enable
};

/*
    control register 1 @ 0X40013000 + 0X00
*/
struct spi1_cr1 : public reg32bit<SPI1_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013000 + 0X00, 0, 1> CPHA;                 // Clock phase
    Property<0X40013000 + 0X00, 1, 1> CPOL;                 // Clock polarity
    Property<0X40013000 + 0X00, 2, 1> MSTR;                 // Master selection
    Property<0X40013000 + 0X00, 3, 3> BR;                   // Baud rate control
    Property<0X40013000 + 0X00, 6, 1> SPE;                  // SPI enable
    Property<0X40013000 + 0X00, 7, 1> LSBFIRST;             // Frame format
    Property<0X40013000 + 0X00, 8, 1> SSI;                  // Internal slave select
    Property<0X40013000 + 0X00, 9, 1> SSM;                  // Software slave management
    Property<0X40013000 + 0X00, 10, 1> RXONLY;              // Receive only
    Property<0X40013000 + 0X00, 11, 1> DFF;                 // Data frame format
    Property<0X40013000 + 0X00, 12, 1> CRCNEXT;             // CRC transfer next
    Property<0X40013000 + 0X00, 13, 1> CRCEN;               // Hardware CRC calculation enable
    Property<0X40013000 + 0X00, 14, 1> BIDIOE;              // Output enable in bidirectional mode
    Property<0X40013000 + 0X00, 15, 1> BIDIMODE;            // Bidirectional data mode enable
};


enum class SPI1_CR2
{
    RXDMAEN,                   // Rx buffer DMA enable
    TXDMAEN,                   // Tx buffer DMA enable
    SSOE,                      // SS output enable
    NSSP,                      // NSS pulse management
    FRF,                       // Frame format
    ERRIE,                     // Error interrupt enable
    RXNEIE,                    // RX buffer not empty interrupt enable
    TXEIE,                     // Tx buffer empty interrupt enable
    DS,                        // Data size
    FRXTH = 12,                // FIFO reception threshold
    LDMA_RX,                   // Last DMA transfer for reception
    LDMA_TX,                   // Last DMA transfer for transmission
};

/*
    control register 2 @ 0X40013000 + 0X04
*/
struct spi1_cr2 : public reg32bit<SPI1_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013000 + 0X04, 0, 1> RXDMAEN;              // Rx buffer DMA enable
    Property<0X40013000 + 0X04, 1, 1> TXDMAEN;              // Tx buffer DMA enable
    Property<0X40013000 + 0X04, 2, 1> SSOE;                 // SS output enable
    Property<0X40013000 + 0X04, 3, 1> NSSP;                 // NSS pulse management
    Property<0X40013000 + 0X04, 4, 1> FRF;                  // Frame format
    Property<0X40013000 + 0X04, 5, 1> ERRIE;                // Error interrupt enable
    Property<0X40013000 + 0X04, 6, 1> RXNEIE;               // RX buffer not empty interrupt enable
    Property<0X40013000 + 0X04, 7, 1> TXEIE;                // Tx buffer empty interrupt enable
    Property<0X40013000 + 0X04, 8, 4> DS;                   // Data size
    Property<0X40013000 + 0X04, 12, 1> FRXTH;               // FIFO reception threshold
    Property<0X40013000 + 0X04, 13, 1> LDMA_RX;             // Last DMA transfer for reception
    Property<0X40013000 + 0X04, 14, 1> LDMA_TX;             // Last DMA transfer for transmission
};


enum class SPI1_SR
{
    RXNE,                      // Receive buffer not empty
    TXE,                       // Transmit buffer empty
    CHSIDE,                    // Channel side
    UDR,                       // Underrun flag
    CRCERR,                    // CRC error flag
    MODF,                      // Mode fault
    OVR,                       // Overrun flag
    BSY,                       // Busy flag
    TIFRFE,                    // TI frame format error
    FRLVL,                     // FIFO reception level
    FTLVL = 11,                // FIFO transmission level
};

/*
    status register @ 0X40013000 + 0X08
*/
struct spi1_sr : public reg32bit<SPI1_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013000 + 0X08, 0, 1> RXNE;                 // Receive buffer not empty
    Property<0X40013000 + 0X08, 1, 1> TXE;                  // Transmit buffer empty
    Property<0X40013000 + 0X08, 2, 1> CHSIDE;               // Channel side
    Property<0X40013000 + 0X08, 3, 1> UDR;                  // Underrun flag
    Property<0X40013000 + 0X08, 4, 1> CRCERR;               // CRC error flag
    Property<0X40013000 + 0X08, 5, 1> MODF;                 // Mode fault
    Property<0X40013000 + 0X08, 6, 1> OVR;                  // Overrun flag
    Property<0X40013000 + 0X08, 7, 1> BSY;                  // Busy flag
    Property<0X40013000 + 0X08, 8, 1> TIFRFE;               // TI frame format error
    Property<0X40013000 + 0X08, 9, 2> FRLVL;                // FIFO reception level
    Property<0X40013000 + 0X08, 11, 2> FTLVL;               // FIFO transmission level
};


enum class SPI1_I2SCFGR
{
    CHLEN,                     // Channel length (number of bits per audio channel)
    DATLEN,                    // Data length to be transferred
    CKPOL = 3,                 // Steady state clock polarity
    I2SSTD,                    // I2S standard selection
    PCMSYNC = 7,               // PCM frame synchronization
    I2SCFG,                    // I2S configuration mode
    I2SE = 10,                 // I2S Enable
    I2SMOD,                    // I2S mode selection
};

/*
    I2S configuration register @ 0X40013000 + 0X1C
*/
struct spi1_i2scfgr : public reg32bit<SPI1_I2SCFGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013000 + 0X1C, 0, 1> CHLEN;                // Channel length (number of bits per audio channel)
    Property<0X40013000 + 0X1C, 1, 2> DATLEN;               // Data length to be transferred
    Property<0X40013000 + 0X1C, 3, 1> CKPOL;                // Steady state clock polarity
    Property<0X40013000 + 0X1C, 4, 2> I2SSTD;               // I2S standard selection
    Property<0X40013000 + 0X1C, 7, 1> PCMSYNC;              // PCM frame synchronization
    Property<0X40013000 + 0X1C, 8, 2> I2SCFG;               // I2S configuration mode
    Property<0X40013000 + 0X1C, 10, 1> I2SE;                // I2S Enable
    Property<0X40013000 + 0X1C, 11, 1> I2SMOD;              // I2S mode selection
};


enum class SPI1_I2SPR
{
    I2SDIV,                    // I2S Linear prescaler
    ODD = 8,                   // Odd factor for the prescaler
    MCKOE,                     // Master clock output enable
};

/*
    I2S prescaler register @ 0X40013000 + 0X20
*/
struct spi1_i2spr : public reg32bit<SPI1_I2SPR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013000 + 0X20, 0, 8> I2SDIV;               // I2S Linear prescaler
    Property<0X40013000 + 0X20, 8, 1> ODD;                  // Odd factor for the prescaler
    Property<0X40013000 + 0X20, 9, 1> MCKOE;                // Master clock output enable
};


/*
    Serial peripheral interface @ 0X40013000
*/
struct SPI1
{
    spi1_cr1 CR1;              // control register 1
    spi1_cr2 CR2;              // control register 2
    spi1_sr SR;                // status register
    regrw DR;                  // data register
    regrw CRCPR;               // CRC polynomial register
    regrw RXCRCR;              // RX CRC register
    regrw TXCRCR;              // TX CRC register
    spi1_i2scfgr I2SCFGR;      // I2S configuration register
    spi1_i2spr I2SPR;          // I2S prescaler register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40013000);}
};


enum class SPI2_CR1
{
    CPHA,                      // Clock phase
    CPOL,                      // Clock polarity
    MSTR,                      // Master selection
    BR,                        // Baud rate control
    SPE = 6,                   // SPI enable
    LSBFIRST,                  // Frame format
    SSI,                       // Internal slave select
    SSM,                       // Software slave management
    RXONLY,                    // Receive only
    DFF,                       // Data frame format
    CRCNEXT,                   // CRC transfer next
    CRCEN,                     // Hardware CRC calculation enable
    BIDIOE,                    // Output enable in bidirectional mode
    BIDIMODE,                  // Bidirectional data mode enable
};

/*
    control register 1 @ 0X40003800 + 0X00
*/
struct spi2_cr1 : public reg32bit<SPI2_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40003800 + 0X00, 0, 1> CPHA;                 // Clock phase
    Property<0X40003800 + 0X00, 1, 1> CPOL;                 // Clock polarity
    Property<0X40003800 + 0X00, 2, 1> MSTR;                 // Master selection
    Property<0X40003800 + 0X00, 3, 3> BR;                   // Baud rate control
    Property<0X40003800 + 0X00, 6, 1> SPE;                  // SPI enable
    Property<0X40003800 + 0X00, 7, 1> LSBFIRST;             // Frame format
    Property<0X40003800 + 0X00, 8, 1> SSI;                  // Internal slave select
    Property<0X40003800 + 0X00, 9, 1> SSM;                  // Software slave management
    Property<0X40003800 + 0X00, 10, 1> RXONLY;              // Receive only
    Property<0X40003800 + 0X00, 11, 1> DFF;                 // Data frame format
    Property<0X40003800 + 0X00, 12, 1> CRCNEXT;             // CRC transfer next
    Property<0X40003800 + 0X00, 13, 1> CRCEN;               // Hardware CRC calculation enable
    Property<0X40003800 + 0X00, 14, 1> BIDIOE;              // Output enable in bidirectional mode
    Property<0X40003800 + 0X00, 15, 1> BIDIMODE;            // Bidirectional data mode enable
};


enum class SPI2_CR2
{
    RXDMAEN,                   // Rx buffer DMA enable
    TXDMAEN,                   // Tx buffer DMA enable
    SSOE,                      // SS output enable
    NSSP,                      // NSS pulse management
    FRF,                       // Frame format
    ERRIE,                     // Error interrupt enable
    RXNEIE,                    // RX buffer not empty interrupt enable
    TXEIE,                     // Tx buffer empty interrupt enable
    DS,                        // Data size
    FRXTH = 12,                // FIFO reception threshold
    LDMA_RX,                   // Last DMA transfer for reception
    LDMA_TX,                   // Last DMA transfer for transmission
};

/*
    control register 2 @ 0X40003800 + 0X04
*/
struct spi2_cr2 : public reg32bit<SPI2_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40003800 + 0X04, 0, 1> RXDMAEN;              // Rx buffer DMA enable
    Property<0X40003800 + 0X04, 1, 1> TXDMAEN;              // Tx buffer DMA enable
    Property<0X40003800 + 0X04, 2, 1> SSOE;                 // SS output enable
    Property<0X40003800 + 0X04, 3, 1> NSSP;                 // NSS pulse management
    Property<0X40003800 + 0X04, 4, 1> FRF;                  // Frame format
    Property<0X40003800 + 0X04, 5, 1> ERRIE;                // Error interrupt enable
    Property<0X40003800 + 0X04, 6, 1> RXNEIE;               // RX buffer not empty interrupt enable
    Property<0X40003800 + 0X04, 7, 1> TXEIE;                // Tx buffer empty interrupt enable
    Property<0X40003800 + 0X04, 8, 4> DS;                   // Data size
    Property<0X40003800 + 0X04, 12, 1> FRXTH;               // FIFO reception threshold
    Property<0X40003800 + 0X04, 13, 1> LDMA_RX;             // Last DMA transfer for reception
    Property<0X40003800 + 0X04, 14, 1> LDMA_TX;             // Last DMA transfer for transmission
};


enum class SPI2_SR
{
    RXNE,                      // Receive buffer not empty
    TXE,                       // Transmit buffer empty
    CHSIDE,                    // Channel side
    UDR,                       // Underrun flag
    CRCERR,                    // CRC error flag
    MODF,                      // Mode fault
    OVR,                       // Overrun flag
    BSY,                       // Busy flag
    TIFRFE,                    // TI frame format error
    FRLVL,                     // FIFO reception level
    FTLVL = 11,                // FIFO transmission level
};

/*
    status register @ 0X40003800 + 0X08
*/
struct spi2_sr : public reg32bit<SPI2_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40003800 + 0X08, 0, 1> RXNE;                 // Receive buffer not empty
    Property<0X40003800 + 0X08, 1, 1> TXE;                  // Transmit buffer empty
    Property<0X40003800 + 0X08, 2, 1> CHSIDE;               // Channel side
    Property<0X40003800 + 0X08, 3, 1> UDR;                  // Underrun flag
    Property<0X40003800 + 0X08, 4, 1> CRCERR;               // CRC error flag
    Property<0X40003800 + 0X08, 5, 1> MODF;                 // Mode fault
    Property<0X40003800 + 0X08, 6, 1> OVR;                  // Overrun flag
    Property<0X40003800 + 0X08, 7, 1> BSY;                  // Busy flag
    Property<0X40003800 + 0X08, 8, 1> TIFRFE;               // TI frame format error
    Property<0X40003800 + 0X08, 9, 2> FRLVL;                // FIFO reception level
    Property<0X40003800 + 0X08, 11, 2> FTLVL;               // FIFO transmission level
};


enum class SPI2_I2SCFGR
{
    CHLEN,                     // Channel length (number of bits per audio channel)
    DATLEN,                    // Data length to be transferred
    CKPOL = 3,                 // Steady state clock polarity
    I2SSTD,                    // I2S standard selection
    PCMSYNC = 7,               // PCM frame synchronization
    I2SCFG,                    // I2S configuration mode
    I2SE = 10,                 // I2S Enable
    I2SMOD,                    // I2S mode selection
};

/*
    I2S configuration register @ 0X40003800 + 0X1C
*/
struct spi2_i2scfgr : public reg32bit<SPI2_I2SCFGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40003800 + 0X1C, 0, 1> CHLEN;                // Channel length (number of bits per audio channel)
    Property<0X40003800 + 0X1C, 1, 2> DATLEN;               // Data length to be transferred
    Property<0X40003800 + 0X1C, 3, 1> CKPOL;                // Steady state clock polarity
    Property<0X40003800 + 0X1C, 4, 2> I2SSTD;               // I2S standard selection
    Property<0X40003800 + 0X1C, 7, 1> PCMSYNC;              // PCM frame synchronization
    Property<0X40003800 + 0X1C, 8, 2> I2SCFG;               // I2S configuration mode
    Property<0X40003800 + 0X1C, 10, 1> I2SE;                // I2S Enable
    Property<0X40003800 + 0X1C, 11, 1> I2SMOD;              // I2S mode selection
};


enum class SPI2_I2SPR
{
    I2SDIV,                    // I2S Linear prescaler
    ODD = 8,                   // Odd factor for the prescaler
    MCKOE,                     // Master clock output enable
};

/*
    I2S prescaler register @ 0X40003800 + 0X20
*/
struct spi2_i2spr : public reg32bit<SPI2_I2SPR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40003800 + 0X20, 0, 8> I2SDIV;               // I2S Linear prescaler
    Property<0X40003800 + 0X20, 8, 1> ODD;                  // Odd factor for the prescaler
    Property<0X40003800 + 0X20, 9, 1> MCKOE;                // Master clock output enable
};


/*
    Serial peripheral interface @ 0X40003800
*/
struct SPI2
{
    spi2_cr1 CR1;              // control register 1
    spi2_cr2 CR2;              // control register 2
    spi2_sr SR;                // status register
    regrw DR;                  // data register
    regrw CRCPR;               // CRC polynomial register
    regrw RXCRCR;              // RX CRC register
    regrw TXCRCR;              // TX CRC register
    spi2_i2scfgr I2SCFGR;      // I2S configuration register
    spi2_i2spr I2SPR;          // I2S prescaler register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40003800);}
};


enum class SYSCFG_CFGR1
{
    MEM_MODE,                  // Memory mapping selection bits
    ADC_DMA_RMP = 8,           // ADC DMA remapping bit
    USART1_TX_DMA_RMP,         // USART1_TX DMA remapping bit
    USART1_RX_DMA_RMP,         // USART1_RX DMA request remapping bit
    TIM16_DMA_RMP,             // TIM16 DMA request remapping bit
    TIM17_DMA_RMP,             // TIM17 DMA request remapping bit
    I2C_PB6_FM = 16,           // Fast Mode Plus (FM plus) driving capability activation bits.
    I2C_PB7_FM,                // Fast Mode Plus (FM+) driving capability activation bits.
    I2C_PB8_FM,                // Fast Mode Plus (FM+) driving capability activation bits.
    I2C_PB9_FM,                // Fast Mode Plus (FM+) driving capability activation bits.
    I2C1_FM_plus,              // FM+ driving capability activation for I2C1
    I2C2_FM_plus,              // FM+ driving capability activation for I2C2
    SPI2_DMA_RMP = 24,         // SPI2 DMA request remapping bit
    USART2_DMA_RMP,            // USART2 DMA request remapping bit
    USART3_DMA_RMP,            // USART3 DMA request remapping bit
    I2C1_DMA_RMP,              // I2C1 DMA request remapping bit
    TIM1_DMA_RMP,              // TIM1 DMA request remapping bit
    TIM2_DMA_RMP,              // TIM2 DMA request remapping bit
    TIM3_DMA_RMP,              // TIM3 DMA request remapping bit
};

/*
    configuration register 1 @ 0X40010000 + 0X00
*/
struct syscfg_cfgr1 : public reg32bit<SYSCFG_CFGR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010000 + 0X00, 0, 2> MEM_MODE;             // Memory mapping selection bits
    Property<0X40010000 + 0X00, 8, 1> ADC_DMA_RMP;          // ADC DMA remapping bit
    Property<0X40010000 + 0X00, 9, 1> USART1_TX_DMA_RMP;    // USART1_TX DMA remapping bit
    Property<0X40010000 + 0X00, 10, 1> USART1_RX_DMA_RMP;   // USART1_RX DMA request remapping bit
    Property<0X40010000 + 0X00, 11, 1> TIM16_DMA_RMP;       // TIM16 DMA request remapping bit
    Property<0X40010000 + 0X00, 12, 1> TIM17_DMA_RMP;       // TIM17 DMA request remapping bit
    Property<0X40010000 + 0X00, 16, 1> I2C_PB6_FM;          // Fast Mode Plus (FM plus) driving capability activation bits.
    Property<0X40010000 + 0X00, 17, 1> I2C_PB7_FM;          // Fast Mode Plus (FM+) driving capability activation bits.
    Property<0X40010000 + 0X00, 18, 1> I2C_PB8_FM;          // Fast Mode Plus (FM+) driving capability activation bits.
    Property<0X40010000 + 0X00, 19, 1> I2C_PB9_FM;          // Fast Mode Plus (FM+) driving capability activation bits.
    Property<0X40010000 + 0X00, 20, 1> I2C1_FM_plus;        // FM+ driving capability activation for I2C1
    Property<0X40010000 + 0X00, 21, 1> I2C2_FM_plus;        // FM+ driving capability activation for I2C2
    Property<0X40010000 + 0X00, 24, 1> SPI2_DMA_RMP;        // SPI2 DMA request remapping bit
    Property<0X40010000 + 0X00, 25, 1> USART2_DMA_RMP;      // USART2 DMA request remapping bit
    Property<0X40010000 + 0X00, 26, 1> USART3_DMA_RMP;      // USART3 DMA request remapping bit
    Property<0X40010000 + 0X00, 27, 1> I2C1_DMA_RMP;        // I2C1 DMA request remapping bit
    Property<0X40010000 + 0X00, 28, 1> TIM1_DMA_RMP;        // TIM1 DMA request remapping bit
    Property<0X40010000 + 0X00, 29, 1> TIM2_DMA_RMP;        // TIM2 DMA request remapping bit
    Property<0X40010000 + 0X00, 30, 1> TIM3_DMA_RMP;        // TIM3 DMA request remapping bit
};


enum class SYSCFG_EXTICR1
{
    EXTI0,                     // EXTI 0 configuration bits
    EXTI1 = 4,                 // EXTI 1 configuration bits
    EXTI2 = 8,                 // EXTI 2 configuration bits
    EXTI3 = 12,                // EXTI 3 configuration bits
};

/*
    external interrupt configuration register 1 @ 0X40010000 + 0X08
*/
struct syscfg_exticr1 : public reg32bit<SYSCFG_EXTICR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010000 + 0X08, 0, 4> EXTI0;                // EXTI 0 configuration bits
    Property<0X40010000 + 0X08, 4, 4> EXTI1;                // EXTI 1 configuration bits
    Property<0X40010000 + 0X08, 8, 4> EXTI2;                // EXTI 2 configuration bits
    Property<0X40010000 + 0X08, 12, 4> EXTI3;               // EXTI 3 configuration bits
};


enum class SYSCFG_EXTICR2
{
    EXTI4,                     // EXTI 4 configuration bits
    EXTI5 = 4,                 // EXTI 5 configuration bits
    EXTI6 = 8,                 // EXTI 6 configuration bits
    EXTI7 = 12,                // EXTI 7 configuration bits
};

/*
    external interrupt configuration register 2 @ 0X40010000 + 0X0C
*/
struct syscfg_exticr2 : public reg32bit<SYSCFG_EXTICR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010000 + 0X0C, 0, 4> EXTI4;                // EXTI 4 configuration bits
    Property<0X40010000 + 0X0C, 4, 4> EXTI5;                // EXTI 5 configuration bits
    Property<0X40010000 + 0X0C, 8, 4> EXTI6;                // EXTI 6 configuration bits
    Property<0X40010000 + 0X0C, 12, 4> EXTI7;               // EXTI 7 configuration bits
};


enum class SYSCFG_EXTICR3
{
    EXTI8,                     // EXTI 8 configuration bits
    EXTI9 = 4,                 // EXTI 9 configuration bits
    EXTI10 = 8,                // EXTI 10 configuration bits
    EXTI11 = 12,               // EXTI 11 configuration bits
};

/*
    external interrupt configuration register 3 @ 0X40010000 + 0X10
*/
struct syscfg_exticr3 : public reg32bit<SYSCFG_EXTICR3>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010000 + 0X10, 0, 4> EXTI8;                // EXTI 8 configuration bits
    Property<0X40010000 + 0X10, 4, 4> EXTI9;                // EXTI 9 configuration bits
    Property<0X40010000 + 0X10, 8, 4> EXTI10;               // EXTI 10 configuration bits
    Property<0X40010000 + 0X10, 12, 4> EXTI11;              // EXTI 11 configuration bits
};


enum class SYSCFG_EXTICR4
{
    EXTI12,                    // EXTI 12 configuration bits
    EXTI13 = 4,                // EXTI 13 configuration bits
    EXTI14 = 8,                // EXTI 14 configuration bits
    EXTI15 = 12,               // EXTI 15 configuration bits
};

/*
    external interrupt configuration register 4 @ 0X40010000 + 0X14
*/
struct syscfg_exticr4 : public reg32bit<SYSCFG_EXTICR4>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010000 + 0X14, 0, 4> EXTI12;               // EXTI 12 configuration bits
    Property<0X40010000 + 0X14, 4, 4> EXTI13;               // EXTI 13 configuration bits
    Property<0X40010000 + 0X14, 8, 4> EXTI14;               // EXTI 14 configuration bits
    Property<0X40010000 + 0X14, 12, 4> EXTI15;              // EXTI 15 configuration bits
};


enum class SYSCFG_CFGR2
{
    LOCUP_LOCK,                // Cortex-M0 LOCKUP bit enable bit
    SRAM_PARITY_LOCK,          // SRAM parity lock bit
    PVD_LOCK,                  // PVD lock enable bit
    SRAM_PEF = 8,              // SRAM parity flag
};

/*
    configuration register 2 @ 0X40010000 + 0X18
*/
struct syscfg_cfgr2 : public reg32bit<SYSCFG_CFGR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40010000 + 0X18, 0, 1> LOCUP_LOCK;           // Cortex-M0 LOCKUP bit enable bit
    Property<0X40010000 + 0X18, 1, 1> SRAM_PARITY_LOCK;     // SRAM parity lock bit
    Property<0X40010000 + 0X18, 2, 1> PVD_LOCK;             // PVD lock enable bit
    Property<0X40010000 + 0X18, 8, 1> SRAM_PEF;             // SRAM parity flag
};


/*
    System configuration controller @ 0X40010000
*/
struct SYSCFG
{
    syscfg_cfgr1 CFGR1;        // configuration register 1
    syscfg_exticr1 EXTICR1;    // external interrupt configuration register 1
    syscfg_exticr2 EXTICR2;    // external interrupt configuration register 2
    syscfg_exticr3 EXTICR3;    // external interrupt configuration register 3
    syscfg_exticr4 EXTICR4;    // external interrupt configuration register 4
    syscfg_cfgr2 CFGR2;        // configuration register 2

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40010000);}
};


enum class TIM1_CR1
{
    CEN,                       // Counter enable
    UDIS,                      // Update disable
    URS,                       // Update request source
    OPM,                       // One-pulse mode
    DIR,                       // Direction
    CMS,                       // Center-aligned mode selection
    ARPE = 7,                  // Auto-reload preload enable
    CKD,                       // Clock division
};

/*
    control register 1 @ 0X40012C00 + 0X00
*/
struct tim1_cr1 : public reg32bit<TIM1_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X00, 0, 1> CEN;                  // Counter enable
    Property<0X40012C00 + 0X00, 1, 1> UDIS;                 // Update disable
    Property<0X40012C00 + 0X00, 2, 1> URS;                  // Update request source
    Property<0X40012C00 + 0X00, 3, 1> OPM;                  // One-pulse mode
    Property<0X40012C00 + 0X00, 4, 1> DIR;                  // Direction
    Property<0X40012C00 + 0X00, 5, 2> CMS;                  // Center-aligned mode selection
    Property<0X40012C00 + 0X00, 7, 1> ARPE;                 // Auto-reload preload enable
    Property<0X40012C00 + 0X00, 8, 2> CKD;                  // Clock division
};


enum class TIM1_CR2
{
    CCPC,                      // Capture/compare preloaded control
    CCUS = 2,                  // Capture/compare control update selection
    CCDS,                      // Capture/compare DMA selection
    MMS,                       // Master mode selection
    TI1S = 7,                  // TI1 selection
    OIS1,                      // Output Idle state 1
    OIS1N,                     // Output Idle state 1
    OIS2,                      // Output Idle state 2
    OIS2N,                     // Output Idle state 2
    OIS3,                      // Output Idle state 3
    OIS3N,                     // Output Idle state 3
    OIS4,                      // Output Idle state 4
};

/*
    control register 2 @ 0X40012C00 + 0X04
*/
struct tim1_cr2 : public reg32bit<TIM1_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X04, 0, 1> CCPC;                 // Capture/compare preloaded control
    Property<0X40012C00 + 0X04, 2, 1> CCUS;                 // Capture/compare control update selection
    Property<0X40012C00 + 0X04, 3, 1> CCDS;                 // Capture/compare DMA selection
    Property<0X40012C00 + 0X04, 4, 3> MMS;                  // Master mode selection
    Property<0X40012C00 + 0X04, 7, 1> TI1S;                 // TI1 selection
    Property<0X40012C00 + 0X04, 8, 1> OIS1;                 // Output Idle state 1
    Property<0X40012C00 + 0X04, 9, 1> OIS1N;                // Output Idle state 1
    Property<0X40012C00 + 0X04, 10, 1> OIS2;                // Output Idle state 2
    Property<0X40012C00 + 0X04, 11, 1> OIS2N;               // Output Idle state 2
    Property<0X40012C00 + 0X04, 12, 1> OIS3;                // Output Idle state 3
    Property<0X40012C00 + 0X04, 13, 1> OIS3N;               // Output Idle state 3
    Property<0X40012C00 + 0X04, 14, 1> OIS4;                // Output Idle state 4
};


enum class TIM1_SMCR
{
    SMS,                       // Slave mode selection
    TS = 4,                    // Trigger selection
    MSM = 7,                   // Master/Slave mode
    ETF,                       // External trigger filter
    ETPS = 12,                 // External trigger prescaler
    ECE = 14,                  // External clock enable
    ETP,                       // External trigger polarity
};

/*
    slave mode control register @ 0X40012C00 + 0X08
*/
struct tim1_smcr : public reg32bit<TIM1_SMCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X08, 0, 3> SMS;                  // Slave mode selection
    Property<0X40012C00 + 0X08, 4, 3> TS;                   // Trigger selection
    Property<0X40012C00 + 0X08, 7, 1> MSM;                  // Master/Slave mode
    Property<0X40012C00 + 0X08, 8, 4> ETF;                  // External trigger filter
    Property<0X40012C00 + 0X08, 12, 2> ETPS;                // External trigger prescaler
    Property<0X40012C00 + 0X08, 14, 1> ECE;                 // External clock enable
    Property<0X40012C00 + 0X08, 15, 1> ETP;                 // External trigger polarity
};


enum class TIM1_DIER
{
    UIE,                       // Update interrupt enable
    CC1IE,                     // Capture/Compare 1 interrupt enable
    CC2IE,                     // Capture/Compare 2 interrupt enable
    CC3IE,                     // Capture/Compare 3 interrupt enable
    CC4IE,                     // Capture/Compare 4 interrupt enable
    COMIE,                     // COM interrupt enable
    TIE,                       // Trigger interrupt enable
    BIE,                       // Break interrupt enable
    UDE,                       // Update DMA request enable
    CC1DE,                     // Capture/Compare 1 DMA request enable
    CC2DE,                     // Capture/Compare 2 DMA request enable
    CC3DE,                     // Capture/Compare 3 DMA request enable
    CC4DE,                     // Capture/Compare 4 DMA request enable
    COMDE,                     // Reserved
    TDE,                       // Trigger DMA request enable
};

/*
    DMA/Interrupt enable register @ 0X40012C00 + 0X0C
*/
struct tim1_dier : public reg32bit<TIM1_DIER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X0C, 0, 1> UIE;                  // Update interrupt enable
    Property<0X40012C00 + 0X0C, 1, 1> CC1IE;                // Capture/Compare 1 interrupt enable
    Property<0X40012C00 + 0X0C, 2, 1> CC2IE;                // Capture/Compare 2 interrupt enable
    Property<0X40012C00 + 0X0C, 3, 1> CC3IE;                // Capture/Compare 3 interrupt enable
    Property<0X40012C00 + 0X0C, 4, 1> CC4IE;                // Capture/Compare 4 interrupt enable
    Property<0X40012C00 + 0X0C, 5, 1> COMIE;                // COM interrupt enable
    Property<0X40012C00 + 0X0C, 6, 1> TIE;                  // Trigger interrupt enable
    Property<0X40012C00 + 0X0C, 7, 1> BIE;                  // Break interrupt enable
    Property<0X40012C00 + 0X0C, 8, 1> UDE;                  // Update DMA request enable
    Property<0X40012C00 + 0X0C, 9, 1> CC1DE;                // Capture/Compare 1 DMA request enable
    Property<0X40012C00 + 0X0C, 10, 1> CC2DE;               // Capture/Compare 2 DMA request enable
    Property<0X40012C00 + 0X0C, 11, 1> CC3DE;               // Capture/Compare 3 DMA request enable
    Property<0X40012C00 + 0X0C, 12, 1> CC4DE;               // Capture/Compare 4 DMA request enable
    Property<0X40012C00 + 0X0C, 13, 1> COMDE;               // Reserved
    Property<0X40012C00 + 0X0C, 14, 1> TDE;                 // Trigger DMA request enable
};


enum class TIM1_SR
{
    UIF,                       // Update interrupt flag
    CC1IF,                     // Capture/compare 1 interrupt flag
    CC2IF,                     // Capture/Compare 2 interrupt flag
    CC3IF,                     // Capture/Compare 3 interrupt flag
    CC4IF,                     // Capture/Compare 4 interrupt flag
    COMIF,                     // COM interrupt flag
    TIF,                       // Trigger interrupt flag
    BIF,                       // Break interrupt flag
    CC1OF = 9,                 // Capture/Compare 1 overcapture flag
    CC2OF,                     // Capture/compare 2 overcapture flag
    CC3OF,                     // Capture/Compare 3 overcapture flag
    CC4OF,                     // Capture/Compare 4 overcapture flag
};

/*
    status register @ 0X40012C00 + 0X10
*/
struct tim1_sr : public reg32bit<TIM1_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X10, 0, 1> UIF;                  // Update interrupt flag
    Property<0X40012C00 + 0X10, 1, 1> CC1IF;                // Capture/compare 1 interrupt flag
    Property<0X40012C00 + 0X10, 2, 1> CC2IF;                // Capture/Compare 2 interrupt flag
    Property<0X40012C00 + 0X10, 3, 1> CC3IF;                // Capture/Compare 3 interrupt flag
    Property<0X40012C00 + 0X10, 4, 1> CC4IF;                // Capture/Compare 4 interrupt flag
    Property<0X40012C00 + 0X10, 5, 1> COMIF;                // COM interrupt flag
    Property<0X40012C00 + 0X10, 6, 1> TIF;                  // Trigger interrupt flag
    Property<0X40012C00 + 0X10, 7, 1> BIF;                  // Break interrupt flag
    Property<0X40012C00 + 0X10, 9, 1> CC1OF;                // Capture/Compare 1 overcapture flag
    Property<0X40012C00 + 0X10, 10, 1> CC2OF;               // Capture/compare 2 overcapture flag
    Property<0X40012C00 + 0X10, 11, 1> CC3OF;               // Capture/Compare 3 overcapture flag
    Property<0X40012C00 + 0X10, 12, 1> CC4OF;               // Capture/Compare 4 overcapture flag
};


enum class TIM1_EGR
{
    UG,                        // Update generation
    CC1G,                      // Capture/compare 1 generation
    CC2G,                      // Capture/compare 2 generation
    CC3G,                      // Capture/compare 3 generation
    CC4G,                      // Capture/compare 4 generation
    COMG,                      // Capture/Compare control update generation
    TG,                        // Trigger generation
    BG,                        // Break generation
};

/*
    event generation register @ 0X40012C00 + 0X14
*/
struct tim1_egr : public reg32bit<TIM1_EGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X14, 0, 1> UG;                   // Update generation
    Property<0X40012C00 + 0X14, 1, 1> CC1G;                 // Capture/compare 1 generation
    Property<0X40012C00 + 0X14, 2, 1> CC2G;                 // Capture/compare 2 generation
    Property<0X40012C00 + 0X14, 3, 1> CC3G;                 // Capture/compare 3 generation
    Property<0X40012C00 + 0X14, 4, 1> CC4G;                 // Capture/compare 4 generation
    Property<0X40012C00 + 0X14, 5, 1> COMG;                 // Capture/Compare control update generation
    Property<0X40012C00 + 0X14, 6, 1> TG;                   // Trigger generation
    Property<0X40012C00 + 0X14, 7, 1> BG;                   // Break generation
};


enum class TIM1_CCMR1_Output
{
    CC1S,                      // Capture/Compare 1 selection
    OC1FE = 2,                 // Output Compare 1 fast enable
    OC1PE,                     // Output Compare 1 preload enable
    OC1M,                      // Output Compare 1 mode
    OC1CE = 7,                 // Output Compare 1 clear enable
    CC2S,                      // Capture/Compare 2 selection
    OC2FE = 10,                // Output Compare 2 fast enable
    OC2PE,                     // Output Compare 2 preload enable
    OC2M,                      // Output Compare 2 mode
    OC2CE = 15,                // Output Compare 2 clear enable
};

/*
    capture/compare mode register (output mode) @ 0X40012C00 + 0X18
*/
struct tim1_ccmr1_output : public reg32bit<TIM1_CCMR1_Output>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40012C00 + 0X18, 2, 1> OC1FE;                // Output Compare 1 fast enable
    Property<0X40012C00 + 0X18, 3, 1> OC1PE;                // Output Compare 1 preload enable
    Property<0X40012C00 + 0X18, 4, 3> OC1M;                 // Output Compare 1 mode
    Property<0X40012C00 + 0X18, 7, 1> OC1CE;                // Output Compare 1 clear enable
    Property<0X40012C00 + 0X18, 8, 2> CC2S;                 // Capture/Compare 2 selection
    Property<0X40012C00 + 0X18, 10, 1> OC2FE;               // Output Compare 2 fast enable
    Property<0X40012C00 + 0X18, 11, 1> OC2PE;               // Output Compare 2 preload enable
    Property<0X40012C00 + 0X18, 12, 3> OC2M;                // Output Compare 2 mode
    Property<0X40012C00 + 0X18, 15, 1> OC2CE;               // Output Compare 2 clear enable
};


enum class TIM1_CCMR1_Input
{
    CC1S,                      // Capture/Compare 1 selection
    IC1PCS = 2,                // Input capture 1 prescaler
    IC1F = 4,                  // Input capture 1 filter
    CC2S = 8,                  // Capture/Compare 2 selection
    IC2PCS = 10,               // Input capture 2 prescaler
    IC2F = 12,                 // Input capture 2 filter
};

/*
    capture/compare mode register 1 (input mode) @ 0X40012C00 + 0X18
*/
struct tim1_ccmr1_input : public reg32bit<TIM1_CCMR1_Input>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40012C00 + 0X18, 2, 2> IC1PCS;               // Input capture 1 prescaler
    Property<0X40012C00 + 0X18, 4, 4> IC1F;                 // Input capture 1 filter
    Property<0X40012C00 + 0X18, 8, 2> CC2S;                 // Capture/Compare 2 selection
    Property<0X40012C00 + 0X18, 10, 2> IC2PCS;              // Input capture 2 prescaler
    Property<0X40012C00 + 0X18, 12, 4> IC2F;                // Input capture 2 filter
};


enum class TIM1_CCMR2_Output
{
    CC3S,                      // Capture/Compare 3 selection
    OC3FE = 2,                 // Output compare 3 fast enable
    OC3PE,                     // Output compare 3 preload enable
    OC3M,                      // Output compare 3 mode
    OC3CE = 7,                 // Output compare 3 clear enable
    CC4S,                      // Capture/Compare 4 selection
    OC4FE = 10,                // Output compare 4 fast enable
    OC4PE,                     // Output compare 4 preload enable
    OC4M,                      // Output compare 4 mode
    OC4CE = 15,                // Output compare 4 clear enable
};

/*
    capture/compare mode register (output mode) @ 0X40012C00 + 0X1C
*/
struct tim1_ccmr2_output : public reg32bit<TIM1_CCMR2_Output>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X1C, 0, 2> CC3S;                 // Capture/Compare 3 selection
    Property<0X40012C00 + 0X1C, 2, 1> OC3FE;                // Output compare 3 fast enable
    Property<0X40012C00 + 0X1C, 3, 1> OC3PE;                // Output compare 3 preload enable
    Property<0X40012C00 + 0X1C, 4, 3> OC3M;                 // Output compare 3 mode
    Property<0X40012C00 + 0X1C, 7, 1> OC3CE;                // Output compare 3 clear enable
    Property<0X40012C00 + 0X1C, 8, 2> CC4S;                 // Capture/Compare 4 selection
    Property<0X40012C00 + 0X1C, 10, 1> OC4FE;               // Output compare 4 fast enable
    Property<0X40012C00 + 0X1C, 11, 1> OC4PE;               // Output compare 4 preload enable
    Property<0X40012C00 + 0X1C, 12, 3> OC4M;                // Output compare 4 mode
    Property<0X40012C00 + 0X1C, 15, 1> OC4CE;               // Output compare 4 clear enable
};


enum class TIM1_CCMR2_Input
{
    CC3S,                      // Capture/compare 3 selection
    IC3PSC = 2,                // Input capture 3 prescaler
    IC3F = 4,                  // Input capture 3 filter
    CC4S = 8,                  // Capture/Compare 4 selection
    IC4PSC = 10,               // Input capture 4 prescaler
    IC4F = 12,                 // Input capture 4 filter
};

/*
    capture/compare mode register 2 (input mode) @ 0X40012C00 + 0X1C
*/
struct tim1_ccmr2_input : public reg32bit<TIM1_CCMR2_Input>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X1C, 0, 2> CC3S;                 // Capture/compare 3 selection
    Property<0X40012C00 + 0X1C, 2, 2> IC3PSC;               // Input capture 3 prescaler
    Property<0X40012C00 + 0X1C, 4, 4> IC3F;                 // Input capture 3 filter
    Property<0X40012C00 + 0X1C, 8, 2> CC4S;                 // Capture/Compare 4 selection
    Property<0X40012C00 + 0X1C, 10, 2> IC4PSC;              // Input capture 4 prescaler
    Property<0X40012C00 + 0X1C, 12, 4> IC4F;                // Input capture 4 filter
};


enum class TIM1_CCER
{
    CC1E,                      // Capture/Compare 1 output enable
    CC1P,                      // Capture/Compare 1 output Polarity
    CC1NE,                     // Capture/Compare 1 complementary output enable
    CC1NP,                     // Capture/Compare 1 output Polarity
    CC2E,                      // Capture/Compare 2 output enable
    CC2P,                      // Capture/Compare 2 output Polarity
    CC2NE,                     // Capture/Compare 2 complementary output enable
    CC2NP,                     // Capture/Compare 2 output Polarity
    CC3E,                      // Capture/Compare 3 output enable
    CC3P,                      // Capture/Compare 3 output Polarity
    CC3NE,                     // Capture/Compare 3 complementary output enable
    CC3NP,                     // Capture/Compare 3 output Polarity
    CC4E,                      // Capture/Compare 4 output enable
    CC4P,                      // Capture/Compare 3 output Polarity
};

/*
    capture/compare enable register @ 0X40012C00 + 0X20
*/
struct tim1_ccer : public reg32bit<TIM1_CCER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X20, 0, 1> CC1E;                 // Capture/Compare 1 output enable
    Property<0X40012C00 + 0X20, 1, 1> CC1P;                 // Capture/Compare 1 output Polarity
    Property<0X40012C00 + 0X20, 2, 1> CC1NE;                // Capture/Compare 1 complementary output enable
    Property<0X40012C00 + 0X20, 3, 1> CC1NP;                // Capture/Compare 1 output Polarity
    Property<0X40012C00 + 0X20, 4, 1> CC2E;                 // Capture/Compare 2 output enable
    Property<0X40012C00 + 0X20, 5, 1> CC2P;                 // Capture/Compare 2 output Polarity
    Property<0X40012C00 + 0X20, 6, 1> CC2NE;                // Capture/Compare 2 complementary output enable
    Property<0X40012C00 + 0X20, 7, 1> CC2NP;                // Capture/Compare 2 output Polarity
    Property<0X40012C00 + 0X20, 8, 1> CC3E;                 // Capture/Compare 3 output enable
    Property<0X40012C00 + 0X20, 9, 1> CC3P;                 // Capture/Compare 3 output Polarity
    Property<0X40012C00 + 0X20, 10, 1> CC3NE;               // Capture/Compare 3 complementary output enable
    Property<0X40012C00 + 0X20, 11, 1> CC3NP;               // Capture/Compare 3 output Polarity
    Property<0X40012C00 + 0X20, 12, 1> CC4E;                // Capture/Compare 4 output enable
    Property<0X40012C00 + 0X20, 13, 1> CC4P;                // Capture/Compare 3 output Polarity
};


enum class TIM1_BDTR
{
    DTG,                       // Dead-time generator setup
    LOCK = 8,                  // Lock configuration
    OSSI = 10,                 // Off-state selection for Idle mode
    OSSR,                      // Off-state selection for Run mode
    BKE,                       // Break enable
    BKP,                       // Break polarity
    AOE,                       // Automatic output enable
    MOE,                       // Main output enable
};

/*
    break and dead-time register @ 0X40012C00 + 0X44
*/
struct tim1_bdtr : public reg32bit<TIM1_BDTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X44, 0, 8> DTG;                  // Dead-time generator setup
    Property<0X40012C00 + 0X44, 8, 2> LOCK;                 // Lock configuration
    Property<0X40012C00 + 0X44, 10, 1> OSSI;                // Off-state selection for Idle mode
    Property<0X40012C00 + 0X44, 11, 1> OSSR;                // Off-state selection for Run mode
    Property<0X40012C00 + 0X44, 12, 1> BKE;                 // Break enable
    Property<0X40012C00 + 0X44, 13, 1> BKP;                 // Break polarity
    Property<0X40012C00 + 0X44, 14, 1> AOE;                 // Automatic output enable
    Property<0X40012C00 + 0X44, 15, 1> MOE;                 // Main output enable
};


enum class TIM1_DCR
{
    DBA,                       // DMA base address
    DBL = 8,                   // DMA burst length
};

/*
    DMA control register @ 0X40012C00 + 0X48
*/
struct tim1_dcr : public reg32bit<TIM1_DCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40012C00 + 0X48, 0, 5> DBA;                  // DMA base address
    Property<0X40012C00 + 0X48, 8, 5> DBL;                  // DMA burst length
};


/*
    Advanced-timers @ 0X40012C00
*/
struct TIM1
{
    tim1_cr1 CR1;              // control register 1
    tim1_cr2 CR2;              // control register 2
    tim1_smcr SMCR;            // slave mode control register
    tim1_dier DIER;            // DMA/Interrupt enable register
    tim1_sr SR;                // status register
    tim1_egr EGR;              // event generation register
    tim1_ccmr1_output CCMR1_Output; // capture/compare mode register (output mode)
    tim1_ccmr1_input CCMR1_Input; // capture/compare mode register 1 (input mode)
    tim1_ccmr2_output CCMR2_Output; // capture/compare mode register (output mode)
    tim1_ccmr2_input CCMR2_Input; // capture/compare mode register 2 (input mode)
    tim1_ccer CCER;            // capture/compare enable register
    regrw CNT;                 // counter
    regrw PSC;                 // prescaler
    regrw ARR;                 // auto-reload register
    regrw RCR;                 // repetition counter register
    regrw CCR1;                // capture/compare register 1
    regrw CCR2;                // capture/compare register 2
    regrw CCR3;                // capture/compare register 3
    regrw CCR4;                // capture/compare register 4
    tim1_bdtr BDTR;            // break and dead-time register
    tim1_dcr DCR;              // DMA control register
    regrw DMAR;                // DMA address for full transfer

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40012C00);}
};


enum class TIM14_CR1
{
    CEN,                       // Counter enable
    UDIS,                      // Update disable
    URS,                       // Update request source
    ARPE = 7,                  // Auto-reload preload enable
    CKD,                       // Clock division
};

/*
    control register 1 @ 0X40002000 + 0X00
*/
struct tim14_cr1 : public reg32bit<TIM14_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002000 + 0X00, 0, 1> CEN;                  // Counter enable
    Property<0X40002000 + 0X00, 1, 1> UDIS;                 // Update disable
    Property<0X40002000 + 0X00, 2, 1> URS;                  // Update request source
    Property<0X40002000 + 0X00, 7, 1> ARPE;                 // Auto-reload preload enable
    Property<0X40002000 + 0X00, 8, 2> CKD;                  // Clock division
};


enum class TIM14_DIER
{
    UIE,                       // Update interrupt enable
    CC1IE,                     // Capture/Compare 1 interrupt enable
};

/*
    DMA/Interrupt enable register @ 0X40002000 + 0X0C
*/
struct tim14_dier : public reg32bit<TIM14_DIER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002000 + 0X0C, 0, 1> UIE;                  // Update interrupt enable
    Property<0X40002000 + 0X0C, 1, 1> CC1IE;                // Capture/Compare 1 interrupt enable
};


enum class TIM14_SR
{
    UIF,                       // Update interrupt flag
    CC1IF,                     // Capture/compare 1 interrupt flag
    CC1OF = 9,                 // Capture/Compare 1 overcapture flag
};

/*
    status register @ 0X40002000 + 0X10
*/
struct tim14_sr : public reg32bit<TIM14_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002000 + 0X10, 0, 1> UIF;                  // Update interrupt flag
    Property<0X40002000 + 0X10, 1, 1> CC1IF;                // Capture/compare 1 interrupt flag
    Property<0X40002000 + 0X10, 9, 1> CC1OF;                // Capture/Compare 1 overcapture flag
};


enum class TIM14_EGR
{
    UG,                        // Update generation
    CC1G,                      // Capture/compare 1 generation
};

/*
    event generation register @ 0X40002000 + 0X14
*/
struct tim14_egr : public reg32bit<TIM14_EGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002000 + 0X14, 0, 1> UG;                   // Update generation
    Property<0X40002000 + 0X14, 1, 1> CC1G;                 // Capture/compare 1 generation
};


enum class TIM14_CCMR1_Output
{
    CC1S,                      // Capture/Compare 1 selection
    OC1FE = 2,                 // Output compare 1 fast enable
    OC1PE,                     // Output Compare 1 preload enable
    OC1M,                      // Output Compare 1 mode
};

/*
    capture/compare mode register (output mode) @ 0X40002000 + 0X18
*/
struct tim14_ccmr1_output : public reg32bit<TIM14_CCMR1_Output>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002000 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40002000 + 0X18, 2, 1> OC1FE;                // Output compare 1 fast enable
    Property<0X40002000 + 0X18, 3, 1> OC1PE;                // Output Compare 1 preload enable
    Property<0X40002000 + 0X18, 4, 3> OC1M;                 // Output Compare 1 mode
};


enum class TIM14_CCMR1_Input
{
    CC1S,                      // Capture/Compare 1 selection
    IC1PSC = 2,                // Input capture 1 prescaler
    IC1F = 4,                  // Input capture 1 filter
};

/*
    capture/compare mode register (input mode) @ 0X40002000 + 0X18
*/
struct tim14_ccmr1_input : public reg32bit<TIM14_CCMR1_Input>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002000 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40002000 + 0X18, 2, 2> IC1PSC;               // Input capture 1 prescaler
    Property<0X40002000 + 0X18, 4, 4> IC1F;                 // Input capture 1 filter
};


enum class TIM14_CCER
{
    CC1E,                      // Capture/Compare 1 output enable
    CC1P,                      // Capture/Compare 1 output Polarity
    CC1NP = 3,                 // Capture/Compare 1 output Polarity
};

/*
    capture/compare enable register @ 0X40002000 + 0X20
*/
struct tim14_ccer : public reg32bit<TIM14_CCER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002000 + 0X20, 0, 1> CC1E;                 // Capture/Compare 1 output enable
    Property<0X40002000 + 0X20, 1, 1> CC1P;                 // Capture/Compare 1 output Polarity
    Property<0X40002000 + 0X20, 3, 1> CC1NP;                // Capture/Compare 1 output Polarity
};


/*
    General-purpose-timers @ 0X40002000
*/
struct TIM14
{
    tim14_cr1 CR1;             // control register 1
    tim14_dier DIER;           // DMA/Interrupt enable register
    tim14_sr SR;               // status register
    tim14_egr EGR;             // event generation register
    tim14_ccmr1_output CCMR1_Output; // capture/compare mode register (output mode)
    tim14_ccmr1_input CCMR1_Input; // capture/compare mode register (input mode)
    tim14_ccer CCER;           // capture/compare enable register
    regrw CNT;                 // counter
    regrw PSC;                 // prescaler
    regrw ARR;                 // auto-reload register
    regrw CCR1;                // capture/compare register 1
    regrw OR;                  // option register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40002000);}
};


enum class TIM15_CR1
{
    CEN,                       // Counter enable
    UDIS,                      // Update disable
    URS,                       // Update request source
    OPM,                       // One-pulse mode
    ARPE = 7,                  // Auto-reload preload enable
    CKD,                       // Clock division
};

/*
    control register 1 @ 0X40014000 + 0X00
*/
struct tim15_cr1 : public reg32bit<TIM15_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X00, 0, 1> CEN;                  // Counter enable
    Property<0X40014000 + 0X00, 1, 1> UDIS;                 // Update disable
    Property<0X40014000 + 0X00, 2, 1> URS;                  // Update request source
    Property<0X40014000 + 0X00, 3, 1> OPM;                  // One-pulse mode
    Property<0X40014000 + 0X00, 7, 1> ARPE;                 // Auto-reload preload enable
    Property<0X40014000 + 0X00, 8, 2> CKD;                  // Clock division
};


enum class TIM15_CR2
{
    CCPC,                      // Capture/compare preloaded control
    CCUS = 2,                  // Capture/compare control update selection
    CCDS,                      // Capture/compare DMA selection
    MMS,                       // Master mode selection
    OIS1 = 8,                  // Output Idle state 1
    OIS1N,                     // Output Idle state 1
    OIS2,                      // Output Idle state 2
};

/*
    control register 2 @ 0X40014000 + 0X04
*/
struct tim15_cr2 : public reg32bit<TIM15_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X04, 0, 1> CCPC;                 // Capture/compare preloaded control
    Property<0X40014000 + 0X04, 2, 1> CCUS;                 // Capture/compare control update selection
    Property<0X40014000 + 0X04, 3, 1> CCDS;                 // Capture/compare DMA selection
    Property<0X40014000 + 0X04, 4, 3> MMS;                  // Master mode selection
    Property<0X40014000 + 0X04, 8, 1> OIS1;                 // Output Idle state 1
    Property<0X40014000 + 0X04, 9, 1> OIS1N;                // Output Idle state 1
    Property<0X40014000 + 0X04, 10, 1> OIS2;                // Output Idle state 2
};


enum class TIM15_SMCR
{
    SMS,                       // Slave mode selection
    TS = 4,                    // Trigger selection
    MSM = 7,                   // Master/Slave mode
};

/*
    slave mode control register @ 0X40014000 + 0X08
*/
struct tim15_smcr : public reg32bit<TIM15_SMCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X08, 0, 3> SMS;                  // Slave mode selection
    Property<0X40014000 + 0X08, 4, 3> TS;                   // Trigger selection
    Property<0X40014000 + 0X08, 7, 1> MSM;                  // Master/Slave mode
};


enum class TIM15_DIER
{
    UIE,                       // Update interrupt enable
    CC1IE,                     // Capture/Compare 1 interrupt enable
    CC2IE,                     // Capture/Compare 2 interrupt enable
    COMIE = 5,                 // COM interrupt enable
    TIE,                       // Trigger interrupt enable
    BIE,                       // Break interrupt enable
    UDE,                       // Update DMA request enable
    CC1DE,                     // Capture/Compare 1 DMA request enable
    CC2DE,                     // Capture/Compare 2 DMA request enable
    TDE = 14,                  // Trigger DMA request enable
};

/*
    DMA/Interrupt enable register @ 0X40014000 + 0X0C
*/
struct tim15_dier : public reg32bit<TIM15_DIER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X0C, 0, 1> UIE;                  // Update interrupt enable
    Property<0X40014000 + 0X0C, 1, 1> CC1IE;                // Capture/Compare 1 interrupt enable
    Property<0X40014000 + 0X0C, 2, 1> CC2IE;                // Capture/Compare 2 interrupt enable
    Property<0X40014000 + 0X0C, 5, 1> COMIE;                // COM interrupt enable
    Property<0X40014000 + 0X0C, 6, 1> TIE;                  // Trigger interrupt enable
    Property<0X40014000 + 0X0C, 7, 1> BIE;                  // Break interrupt enable
    Property<0X40014000 + 0X0C, 8, 1> UDE;                  // Update DMA request enable
    Property<0X40014000 + 0X0C, 9, 1> CC1DE;                // Capture/Compare 1 DMA request enable
    Property<0X40014000 + 0X0C, 10, 1> CC2DE;               // Capture/Compare 2 DMA request enable
    Property<0X40014000 + 0X0C, 14, 1> TDE;                 // Trigger DMA request enable
};


enum class TIM15_SR
{
    UIF,                       // Update interrupt flag
    CC1IF,                     // Capture/compare 1 interrupt flag
    CC2IF,                     // Capture/Compare 2 interrupt flag
    COMIF = 5,                 // COM interrupt flag
    TIF,                       // Trigger interrupt flag
    BIF,                       // Break interrupt flag
    CC1OF = 9,                 // Capture/Compare 1 overcapture flag
    CC2OF,                     // Capture/compare 2 overcapture flag
};

/*
    status register @ 0X40014000 + 0X10
*/
struct tim15_sr : public reg32bit<TIM15_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X10, 0, 1> UIF;                  // Update interrupt flag
    Property<0X40014000 + 0X10, 1, 1> CC1IF;                // Capture/compare 1 interrupt flag
    Property<0X40014000 + 0X10, 2, 1> CC2IF;                // Capture/Compare 2 interrupt flag
    Property<0X40014000 + 0X10, 5, 1> COMIF;                // COM interrupt flag
    Property<0X40014000 + 0X10, 6, 1> TIF;                  // Trigger interrupt flag
    Property<0X40014000 + 0X10, 7, 1> BIF;                  // Break interrupt flag
    Property<0X40014000 + 0X10, 9, 1> CC1OF;                // Capture/Compare 1 overcapture flag
    Property<0X40014000 + 0X10, 10, 1> CC2OF;               // Capture/compare 2 overcapture flag
};


enum class TIM15_EGR
{
    UG,                        // Update generation
    CC1G,                      // Capture/compare 1 generation
    CC2G,                      // Capture/compare 2 generation
    COMG = 5,                  // Capture/Compare control update generation
    TG,                        // Trigger generation
    BG,                        // Break generation
};

/*
    event generation register @ 0X40014000 + 0X14
*/
struct tim15_egr : public reg32bit<TIM15_EGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X14, 0, 1> UG;                   // Update generation
    Property<0X40014000 + 0X14, 1, 1> CC1G;                 // Capture/compare 1 generation
    Property<0X40014000 + 0X14, 2, 1> CC2G;                 // Capture/compare 2 generation
    Property<0X40014000 + 0X14, 5, 1> COMG;                 // Capture/Compare control update generation
    Property<0X40014000 + 0X14, 6, 1> TG;                   // Trigger generation
    Property<0X40014000 + 0X14, 7, 1> BG;                   // Break generation
};


enum class TIM15_CCMR1_Output
{
    CC1S,                      // Capture/Compare 1 selection
    OC1FE = 2,                 // Output Compare 1 fast enable
    OC1PE,                     // Output Compare 1 preload enable
    OC1M,                      // Output Compare 1 mode
    CC2S = 8,                  // Capture/Compare 2 selection
    OC2FE = 10,                // Output Compare 2 fast enable
    OC2PE,                     // Output Compare 2 preload enable
    OC2M,                      // Output Compare 2 mode
};

/*
    capture/compare mode register (output mode) @ 0X40014000 + 0X18
*/
struct tim15_ccmr1_output : public reg32bit<TIM15_CCMR1_Output>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40014000 + 0X18, 2, 1> OC1FE;                // Output Compare 1 fast enable
    Property<0X40014000 + 0X18, 3, 1> OC1PE;                // Output Compare 1 preload enable
    Property<0X40014000 + 0X18, 4, 3> OC1M;                 // Output Compare 1 mode
    Property<0X40014000 + 0X18, 8, 2> CC2S;                 // Capture/Compare 2 selection
    Property<0X40014000 + 0X18, 10, 1> OC2FE;               // Output Compare 2 fast enable
    Property<0X40014000 + 0X18, 11, 1> OC2PE;               // Output Compare 2 preload enable
    Property<0X40014000 + 0X18, 12, 3> OC2M;                // Output Compare 2 mode
};


enum class TIM15_CCMR1_Input
{
    CC1S,                      // Capture/Compare 1 selection
    IC1PSC = 2,                // Input capture 1 prescaler
    IC1F = 4,                  // Input capture 1 filter
    CC2S = 8,                  // Capture/Compare 2 selection
    IC2PSC = 10,               // Input capture 2 prescaler
    IC2F = 12,                 // Input capture 2 filter
};

/*
    capture/compare mode register 1 (input mode) @ 0X40014000 + 0X18
*/
struct tim15_ccmr1_input : public reg32bit<TIM15_CCMR1_Input>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40014000 + 0X18, 2, 2> IC1PSC;               // Input capture 1 prescaler
    Property<0X40014000 + 0X18, 4, 4> IC1F;                 // Input capture 1 filter
    Property<0X40014000 + 0X18, 8, 2> CC2S;                 // Capture/Compare 2 selection
    Property<0X40014000 + 0X18, 10, 2> IC2PSC;              // Input capture 2 prescaler
    Property<0X40014000 + 0X18, 12, 4> IC2F;                // Input capture 2 filter
};


enum class TIM15_CCER
{
    CC1E,                      // Capture/Compare 1 output enable
    CC1P,                      // Capture/Compare 1 output Polarity
    CC1NE,                     // Capture/Compare 1 complementary output enable
    CC1NP,                     // Capture/Compare 1 output Polarity
    CC2E,                      // Capture/Compare 2 output enable
    CC2P,                      // Capture/Compare 2 output Polarity
    CC2NP = 7,                 // Capture/Compare 2 output Polarity
};

/*
    capture/compare enable register @ 0X40014000 + 0X20
*/
struct tim15_ccer : public reg32bit<TIM15_CCER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X20, 0, 1> CC1E;                 // Capture/Compare 1 output enable
    Property<0X40014000 + 0X20, 1, 1> CC1P;                 // Capture/Compare 1 output Polarity
    Property<0X40014000 + 0X20, 2, 1> CC1NE;                // Capture/Compare 1 complementary output enable
    Property<0X40014000 + 0X20, 3, 1> CC1NP;                // Capture/Compare 1 output Polarity
    Property<0X40014000 + 0X20, 4, 1> CC2E;                 // Capture/Compare 2 output enable
    Property<0X40014000 + 0X20, 5, 1> CC2P;                 // Capture/Compare 2 output Polarity
    Property<0X40014000 + 0X20, 7, 1> CC2NP;                // Capture/Compare 2 output Polarity
};


enum class TIM15_BDTR
{
    DTG,                       // Dead-time generator setup
    LOCK = 8,                  // Lock configuration
    OSSI = 10,                 // Off-state selection for Idle mode
    OSSR,                      // Off-state selection for Run mode
    BKE,                       // Break enable
    BKP,                       // Break polarity
    AOE,                       // Automatic output enable
    MOE,                       // Main output enable
};

/*
    break and dead-time register @ 0X40014000 + 0X44
*/
struct tim15_bdtr : public reg32bit<TIM15_BDTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X44, 0, 8> DTG;                  // Dead-time generator setup
    Property<0X40014000 + 0X44, 8, 2> LOCK;                 // Lock configuration
    Property<0X40014000 + 0X44, 10, 1> OSSI;                // Off-state selection for Idle mode
    Property<0X40014000 + 0X44, 11, 1> OSSR;                // Off-state selection for Run mode
    Property<0X40014000 + 0X44, 12, 1> BKE;                 // Break enable
    Property<0X40014000 + 0X44, 13, 1> BKP;                 // Break polarity
    Property<0X40014000 + 0X44, 14, 1> AOE;                 // Automatic output enable
    Property<0X40014000 + 0X44, 15, 1> MOE;                 // Main output enable
};


enum class TIM15_DCR
{
    DBA,                       // DMA base address
    DBL = 8,                   // DMA burst length
};

/*
    DMA control register @ 0X40014000 + 0X48
*/
struct tim15_dcr : public reg32bit<TIM15_DCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014000 + 0X48, 0, 5> DBA;                  // DMA base address
    Property<0X40014000 + 0X48, 8, 5> DBL;                  // DMA burst length
};


/*
    General-purpose-timers @ 0X40014000
*/
struct TIM15
{
    tim15_cr1 CR1;             // control register 1
    tim15_cr2 CR2;             // control register 2
    tim15_smcr SMCR;           // slave mode control register
    tim15_dier DIER;           // DMA/Interrupt enable register
    tim15_sr SR;               // status register
    tim15_egr EGR;             // event generation register
    tim15_ccmr1_output CCMR1_Output; // capture/compare mode register (output mode)
    tim15_ccmr1_input CCMR1_Input; // capture/compare mode register 1 (input mode)
    tim15_ccer CCER;           // capture/compare enable register
    regrw CNT;                 // counter
    regrw PSC;                 // prescaler
    regrw ARR;                 // auto-reload register
    regrw RCR;                 // repetition counter register
    regrw CCR1;                // capture/compare register 1
    regrw CCR2;                // capture/compare register 2
    tim15_bdtr BDTR;           // break and dead-time register
    tim15_dcr DCR;             // DMA control register
    regrw DMAR;                // DMA address for full transfer

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40014000);}
};


enum class TIM16_CR1
{
    CEN,                       // Counter enable
    UDIS,                      // Update disable
    URS,                       // Update request source
    OPM,                       // One-pulse mode
    ARPE = 7,                  // Auto-reload preload enable
    CKD,                       // Clock division
};

/*
    control register 1 @ 0X40014400 + 0X00
*/
struct tim16_cr1 : public reg32bit<TIM16_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X00, 0, 1> CEN;                  // Counter enable
    Property<0X40014400 + 0X00, 1, 1> UDIS;                 // Update disable
    Property<0X40014400 + 0X00, 2, 1> URS;                  // Update request source
    Property<0X40014400 + 0X00, 3, 1> OPM;                  // One-pulse mode
    Property<0X40014400 + 0X00, 7, 1> ARPE;                 // Auto-reload preload enable
    Property<0X40014400 + 0X00, 8, 2> CKD;                  // Clock division
};


enum class TIM16_CR2
{
    CCPC,                      // Capture/compare preloaded control
    CCUS = 2,                  // Capture/compare control update selection
    CCDS,                      // Capture/compare DMA selection
    OIS1 = 8,                  // Output Idle state 1
    OIS1N,                     // Output Idle state 1
};

/*
    control register 2 @ 0X40014400 + 0X04
*/
struct tim16_cr2 : public reg32bit<TIM16_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X04, 0, 1> CCPC;                 // Capture/compare preloaded control
    Property<0X40014400 + 0X04, 2, 1> CCUS;                 // Capture/compare control update selection
    Property<0X40014400 + 0X04, 3, 1> CCDS;                 // Capture/compare DMA selection
    Property<0X40014400 + 0X04, 8, 1> OIS1;                 // Output Idle state 1
    Property<0X40014400 + 0X04, 9, 1> OIS1N;                // Output Idle state 1
};


enum class TIM16_DIER
{
    UIE,                       // Update interrupt enable
    CC1IE,                     // Capture/Compare 1 interrupt enable
    COMIE = 5,                 // COM interrupt enable
    TIE,                       // Trigger interrupt enable
    BIE,                       // Break interrupt enable
    UDE,                       // Update DMA request enable
    CC1DE,                     // Capture/Compare 1 DMA request enable
    TDE = 14,                  // Trigger DMA request enable
};

/*
    DMA/Interrupt enable register @ 0X40014400 + 0X0C
*/
struct tim16_dier : public reg32bit<TIM16_DIER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X0C, 0, 1> UIE;                  // Update interrupt enable
    Property<0X40014400 + 0X0C, 1, 1> CC1IE;                // Capture/Compare 1 interrupt enable
    Property<0X40014400 + 0X0C, 5, 1> COMIE;                // COM interrupt enable
    Property<0X40014400 + 0X0C, 6, 1> TIE;                  // Trigger interrupt enable
    Property<0X40014400 + 0X0C, 7, 1> BIE;                  // Break interrupt enable
    Property<0X40014400 + 0X0C, 8, 1> UDE;                  // Update DMA request enable
    Property<0X40014400 + 0X0C, 9, 1> CC1DE;                // Capture/Compare 1 DMA request enable
    Property<0X40014400 + 0X0C, 14, 1> TDE;                 // Trigger DMA request enable
};


enum class TIM16_SR
{
    UIF,                       // Update interrupt flag
    CC1IF,                     // Capture/compare 1 interrupt flag
    COMIF = 5,                 // COM interrupt flag
    TIF,                       // Trigger interrupt flag
    BIF,                       // Break interrupt flag
    CC1OF = 9,                 // Capture/Compare 1 overcapture flag
};

/*
    status register @ 0X40014400 + 0X10
*/
struct tim16_sr : public reg32bit<TIM16_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X10, 0, 1> UIF;                  // Update interrupt flag
    Property<0X40014400 + 0X10, 1, 1> CC1IF;                // Capture/compare 1 interrupt flag
    Property<0X40014400 + 0X10, 5, 1> COMIF;                // COM interrupt flag
    Property<0X40014400 + 0X10, 6, 1> TIF;                  // Trigger interrupt flag
    Property<0X40014400 + 0X10, 7, 1> BIF;                  // Break interrupt flag
    Property<0X40014400 + 0X10, 9, 1> CC1OF;                // Capture/Compare 1 overcapture flag
};


enum class TIM16_EGR
{
    UG,                        // Update generation
    CC1G,                      // Capture/compare 1 generation
    COMG = 5,                  // Capture/Compare control update generation
    TG,                        // Trigger generation
    BG,                        // Break generation
};

/*
    event generation register @ 0X40014400 + 0X14
*/
struct tim16_egr : public reg32bit<TIM16_EGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X14, 0, 1> UG;                   // Update generation
    Property<0X40014400 + 0X14, 1, 1> CC1G;                 // Capture/compare 1 generation
    Property<0X40014400 + 0X14, 5, 1> COMG;                 // Capture/Compare control update generation
    Property<0X40014400 + 0X14, 6, 1> TG;                   // Trigger generation
    Property<0X40014400 + 0X14, 7, 1> BG;                   // Break generation
};


enum class TIM16_CCMR1_Output
{
    CC1S,                      // Capture/Compare 1 selection
    OC1FE = 2,                 // Output Compare 1 fast enable
    OC1PE,                     // Output Compare 1 preload enable
    OC1M,                      // Output Compare 1 mode
};

/*
    capture/compare mode register (output mode) @ 0X40014400 + 0X18
*/
struct tim16_ccmr1_output : public reg32bit<TIM16_CCMR1_Output>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40014400 + 0X18, 2, 1> OC1FE;                // Output Compare 1 fast enable
    Property<0X40014400 + 0X18, 3, 1> OC1PE;                // Output Compare 1 preload enable
    Property<0X40014400 + 0X18, 4, 3> OC1M;                 // Output Compare 1 mode
};


enum class TIM16_CCMR1_Input
{
    CC1S,                      // Capture/Compare 1 selection
    IC1PSC = 2,                // Input capture 1 prescaler
    IC1F = 4,                  // Input capture 1 filter
};

/*
    capture/compare mode register 1 (input mode) @ 0X40014400 + 0X18
*/
struct tim16_ccmr1_input : public reg32bit<TIM16_CCMR1_Input>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40014400 + 0X18, 2, 2> IC1PSC;               // Input capture 1 prescaler
    Property<0X40014400 + 0X18, 4, 4> IC1F;                 // Input capture 1 filter
};


enum class TIM16_CCER
{
    CC1E,                      // Capture/Compare 1 output enable
    CC1P,                      // Capture/Compare 1 output Polarity
    CC1NE,                     // Capture/Compare 1 complementary output enable
    CC1NP,                     // Capture/Compare 1 output Polarity
};

/*
    capture/compare enable register @ 0X40014400 + 0X20
*/
struct tim16_ccer : public reg32bit<TIM16_CCER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X20, 0, 1> CC1E;                 // Capture/Compare 1 output enable
    Property<0X40014400 + 0X20, 1, 1> CC1P;                 // Capture/Compare 1 output Polarity
    Property<0X40014400 + 0X20, 2, 1> CC1NE;                // Capture/Compare 1 complementary output enable
    Property<0X40014400 + 0X20, 3, 1> CC1NP;                // Capture/Compare 1 output Polarity
};


enum class TIM16_BDTR
{
    DTG,                       // Dead-time generator setup
    LOCK = 8,                  // Lock configuration
    OSSI = 10,                 // Off-state selection for Idle mode
    OSSR,                      // Off-state selection for Run mode
    BKE,                       // Break enable
    BKP,                       // Break polarity
    AOE,                       // Automatic output enable
    MOE,                       // Main output enable
};

/*
    break and dead-time register @ 0X40014400 + 0X44
*/
struct tim16_bdtr : public reg32bit<TIM16_BDTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X44, 0, 8> DTG;                  // Dead-time generator setup
    Property<0X40014400 + 0X44, 8, 2> LOCK;                 // Lock configuration
    Property<0X40014400 + 0X44, 10, 1> OSSI;                // Off-state selection for Idle mode
    Property<0X40014400 + 0X44, 11, 1> OSSR;                // Off-state selection for Run mode
    Property<0X40014400 + 0X44, 12, 1> BKE;                 // Break enable
    Property<0X40014400 + 0X44, 13, 1> BKP;                 // Break polarity
    Property<0X40014400 + 0X44, 14, 1> AOE;                 // Automatic output enable
    Property<0X40014400 + 0X44, 15, 1> MOE;                 // Main output enable
};


enum class TIM16_DCR
{
    DBA,                       // DMA base address
    DBL = 8,                   // DMA burst length
};

/*
    DMA control register @ 0X40014400 + 0X48
*/
struct tim16_dcr : public reg32bit<TIM16_DCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014400 + 0X48, 0, 5> DBA;                  // DMA base address
    Property<0X40014400 + 0X48, 8, 5> DBL;                  // DMA burst length
};


/*
    General-purpose-timers @ 0X40014400
*/
struct TIM16
{
    tim16_cr1 CR1;             // control register 1
    tim16_cr2 CR2;             // control register 2
    tim16_dier DIER;           // DMA/Interrupt enable register
    tim16_sr SR;               // status register
    tim16_egr EGR;             // event generation register
    tim16_ccmr1_output CCMR1_Output; // capture/compare mode register (output mode)
    tim16_ccmr1_input CCMR1_Input; // capture/compare mode register 1 (input mode)
    tim16_ccer CCER;           // capture/compare enable register
    regrw CNT;                 // counter
    regrw PSC;                 // prescaler
    regrw ARR;                 // auto-reload register
    regrw RCR;                 // repetition counter register
    regrw CCR1;                // capture/compare register 1
    tim16_bdtr BDTR;           // break and dead-time register
    tim16_dcr DCR;             // DMA control register
    regrw DMAR;                // DMA address for full transfer

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40014400);}
};


enum class TIM17_CR1
{
    CEN,                       // Counter enable
    UDIS,                      // Update disable
    URS,                       // Update request source
    OPM,                       // One-pulse mode
    ARPE = 7,                  // Auto-reload preload enable
    CKD,                       // Clock division
};

/*
    control register 1 @ 0X40014800 + 0X00
*/
struct tim17_cr1 : public reg32bit<TIM17_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X00, 0, 1> CEN;                  // Counter enable
    Property<0X40014800 + 0X00, 1, 1> UDIS;                 // Update disable
    Property<0X40014800 + 0X00, 2, 1> URS;                  // Update request source
    Property<0X40014800 + 0X00, 3, 1> OPM;                  // One-pulse mode
    Property<0X40014800 + 0X00, 7, 1> ARPE;                 // Auto-reload preload enable
    Property<0X40014800 + 0X00, 8, 2> CKD;                  // Clock division
};


enum class TIM17_CR2
{
    CCPC,                      // Capture/compare preloaded control
    CCUS = 2,                  // Capture/compare control update selection
    CCDS,                      // Capture/compare DMA selection
    OIS1 = 8,                  // Output Idle state 1
    OIS1N,                     // Output Idle state 1
};

/*
    control register 2 @ 0X40014800 + 0X04
*/
struct tim17_cr2 : public reg32bit<TIM17_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X04, 0, 1> CCPC;                 // Capture/compare preloaded control
    Property<0X40014800 + 0X04, 2, 1> CCUS;                 // Capture/compare control update selection
    Property<0X40014800 + 0X04, 3, 1> CCDS;                 // Capture/compare DMA selection
    Property<0X40014800 + 0X04, 8, 1> OIS1;                 // Output Idle state 1
    Property<0X40014800 + 0X04, 9, 1> OIS1N;                // Output Idle state 1
};


enum class TIM17_DIER
{
    UIE,                       // Update interrupt enable
    CC1IE,                     // Capture/Compare 1 interrupt enable
    COMIE = 5,                 // COM interrupt enable
    TIE,                       // Trigger interrupt enable
    BIE,                       // Break interrupt enable
    UDE,                       // Update DMA request enable
    CC1DE,                     // Capture/Compare 1 DMA request enable
    TDE = 14,                  // Trigger DMA request enable
};

/*
    DMA/Interrupt enable register @ 0X40014800 + 0X0C
*/
struct tim17_dier : public reg32bit<TIM17_DIER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X0C, 0, 1> UIE;                  // Update interrupt enable
    Property<0X40014800 + 0X0C, 1, 1> CC1IE;                // Capture/Compare 1 interrupt enable
    Property<0X40014800 + 0X0C, 5, 1> COMIE;                // COM interrupt enable
    Property<0X40014800 + 0X0C, 6, 1> TIE;                  // Trigger interrupt enable
    Property<0X40014800 + 0X0C, 7, 1> BIE;                  // Break interrupt enable
    Property<0X40014800 + 0X0C, 8, 1> UDE;                  // Update DMA request enable
    Property<0X40014800 + 0X0C, 9, 1> CC1DE;                // Capture/Compare 1 DMA request enable
    Property<0X40014800 + 0X0C, 14, 1> TDE;                 // Trigger DMA request enable
};


enum class TIM17_SR
{
    UIF,                       // Update interrupt flag
    CC1IF,                     // Capture/compare 1 interrupt flag
    COMIF = 5,                 // COM interrupt flag
    TIF,                       // Trigger interrupt flag
    BIF,                       // Break interrupt flag
    CC1OF = 9,                 // Capture/Compare 1 overcapture flag
};

/*
    status register @ 0X40014800 + 0X10
*/
struct tim17_sr : public reg32bit<TIM17_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X10, 0, 1> UIF;                  // Update interrupt flag
    Property<0X40014800 + 0X10, 1, 1> CC1IF;                // Capture/compare 1 interrupt flag
    Property<0X40014800 + 0X10, 5, 1> COMIF;                // COM interrupt flag
    Property<0X40014800 + 0X10, 6, 1> TIF;                  // Trigger interrupt flag
    Property<0X40014800 + 0X10, 7, 1> BIF;                  // Break interrupt flag
    Property<0X40014800 + 0X10, 9, 1> CC1OF;                // Capture/Compare 1 overcapture flag
};


enum class TIM17_EGR
{
    UG,                        // Update generation
    CC1G,                      // Capture/compare 1 generation
    COMG = 5,                  // Capture/Compare control update generation
    TG,                        // Trigger generation
    BG,                        // Break generation
};

/*
    event generation register @ 0X40014800 + 0X14
*/
struct tim17_egr : public reg32bit<TIM17_EGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X14, 0, 1> UG;                   // Update generation
    Property<0X40014800 + 0X14, 1, 1> CC1G;                 // Capture/compare 1 generation
    Property<0X40014800 + 0X14, 5, 1> COMG;                 // Capture/Compare control update generation
    Property<0X40014800 + 0X14, 6, 1> TG;                   // Trigger generation
    Property<0X40014800 + 0X14, 7, 1> BG;                   // Break generation
};


enum class TIM17_CCMR1_Output
{
    CC1S,                      // Capture/Compare 1 selection
    OC1FE = 2,                 // Output Compare 1 fast enable
    OC1PE,                     // Output Compare 1 preload enable
    OC1M,                      // Output Compare 1 mode
};

/*
    capture/compare mode register (output mode) @ 0X40014800 + 0X18
*/
struct tim17_ccmr1_output : public reg32bit<TIM17_CCMR1_Output>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40014800 + 0X18, 2, 1> OC1FE;                // Output Compare 1 fast enable
    Property<0X40014800 + 0X18, 3, 1> OC1PE;                // Output Compare 1 preload enable
    Property<0X40014800 + 0X18, 4, 3> OC1M;                 // Output Compare 1 mode
};


enum class TIM17_CCMR1_Input
{
    CC1S,                      // Capture/Compare 1 selection
    IC1PSC = 2,                // Input capture 1 prescaler
    IC1F = 4,                  // Input capture 1 filter
};

/*
    capture/compare mode register 1 (input mode) @ 0X40014800 + 0X18
*/
struct tim17_ccmr1_input : public reg32bit<TIM17_CCMR1_Input>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40014800 + 0X18, 2, 2> IC1PSC;               // Input capture 1 prescaler
    Property<0X40014800 + 0X18, 4, 4> IC1F;                 // Input capture 1 filter
};


enum class TIM17_CCER
{
    CC1E,                      // Capture/Compare 1 output enable
    CC1P,                      // Capture/Compare 1 output Polarity
    CC1NE,                     // Capture/Compare 1 complementary output enable
    CC1NP,                     // Capture/Compare 1 output Polarity
};

/*
    capture/compare enable register @ 0X40014800 + 0X20
*/
struct tim17_ccer : public reg32bit<TIM17_CCER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X20, 0, 1> CC1E;                 // Capture/Compare 1 output enable
    Property<0X40014800 + 0X20, 1, 1> CC1P;                 // Capture/Compare 1 output Polarity
    Property<0X40014800 + 0X20, 2, 1> CC1NE;                // Capture/Compare 1 complementary output enable
    Property<0X40014800 + 0X20, 3, 1> CC1NP;                // Capture/Compare 1 output Polarity
};


enum class TIM17_BDTR
{
    DTG,                       // Dead-time generator setup
    LOCK = 8,                  // Lock configuration
    OSSI = 10,                 // Off-state selection for Idle mode
    OSSR,                      // Off-state selection for Run mode
    BKE,                       // Break enable
    BKP,                       // Break polarity
    AOE,                       // Automatic output enable
    MOE,                       // Main output enable
};

/*
    break and dead-time register @ 0X40014800 + 0X44
*/
struct tim17_bdtr : public reg32bit<TIM17_BDTR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X44, 0, 8> DTG;                  // Dead-time generator setup
    Property<0X40014800 + 0X44, 8, 2> LOCK;                 // Lock configuration
    Property<0X40014800 + 0X44, 10, 1> OSSI;                // Off-state selection for Idle mode
    Property<0X40014800 + 0X44, 11, 1> OSSR;                // Off-state selection for Run mode
    Property<0X40014800 + 0X44, 12, 1> BKE;                 // Break enable
    Property<0X40014800 + 0X44, 13, 1> BKP;                 // Break polarity
    Property<0X40014800 + 0X44, 14, 1> AOE;                 // Automatic output enable
    Property<0X40014800 + 0X44, 15, 1> MOE;                 // Main output enable
};


enum class TIM17_DCR
{
    DBA,                       // DMA base address
    DBL = 8,                   // DMA burst length
};

/*
    DMA control register @ 0X40014800 + 0X48
*/
struct tim17_dcr : public reg32bit<TIM17_DCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40014800 + 0X48, 0, 5> DBA;                  // DMA base address
    Property<0X40014800 + 0X48, 8, 5> DBL;                  // DMA burst length
};


/*
    General-purpose-timers @ 0X40014800
*/
struct TIM17
{
    tim17_cr1 CR1;             // control register 1
    tim17_cr2 CR2;             // control register 2
    tim17_dier DIER;           // DMA/Interrupt enable register
    tim17_sr SR;               // status register
    tim17_egr EGR;             // event generation register
    tim17_ccmr1_output CCMR1_Output; // capture/compare mode register (output mode)
    tim17_ccmr1_input CCMR1_Input; // capture/compare mode register 1 (input mode)
    tim17_ccer CCER;           // capture/compare enable register
    regrw CNT;                 // counter
    regrw PSC;                 // prescaler
    regrw ARR;                 // auto-reload register
    regrw RCR;                 // repetition counter register
    regrw CCR1;                // capture/compare register 1
    tim17_bdtr BDTR;           // break and dead-time register
    tim17_dcr DCR;             // DMA control register
    regrw DMAR;                // DMA address for full transfer

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40014800);}
};


enum class TIM3_CR1
{
    CEN,                       // Counter enable
    UDIS,                      // Update disable
    URS,                       // Update request source
    OPM,                       // One-pulse mode
    DIR,                       // Direction
    CMS,                       // Center-aligned mode selection
    ARPE = 7,                  // Auto-reload preload enable
    CKD,                       // Clock division
};

/*
    control register 1 @ 0X40000400 + 0X00
*/
struct tim3_cr1 : public reg32bit<TIM3_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X00, 0, 1> CEN;                  // Counter enable
    Property<0X40000400 + 0X00, 1, 1> UDIS;                 // Update disable
    Property<0X40000400 + 0X00, 2, 1> URS;                  // Update request source
    Property<0X40000400 + 0X00, 3, 1> OPM;                  // One-pulse mode
    Property<0X40000400 + 0X00, 4, 1> DIR;                  // Direction
    Property<0X40000400 + 0X00, 5, 2> CMS;                  // Center-aligned mode selection
    Property<0X40000400 + 0X00, 7, 1> ARPE;                 // Auto-reload preload enable
    Property<0X40000400 + 0X00, 8, 2> CKD;                  // Clock division
};


enum class TIM3_CR2
{
    CCDS = 3,                  // Capture/compare DMA selection
    MMS,                       // Master mode selection
    TI1S = 7,                  // TI1 selection
};

/*
    control register 2 @ 0X40000400 + 0X04
*/
struct tim3_cr2 : public reg32bit<TIM3_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X04, 3, 1> CCDS;                 // Capture/compare DMA selection
    Property<0X40000400 + 0X04, 4, 3> MMS;                  // Master mode selection
    Property<0X40000400 + 0X04, 7, 1> TI1S;                 // TI1 selection
};


enum class TIM3_SMCR
{
    SMS,                       // Slave mode selection
    TS = 4,                    // Trigger selection
    MSM = 7,                   // Master/Slave mode
    ETF,                       // External trigger filter
    ETPS = 12,                 // External trigger prescaler
    ECE = 14,                  // External clock enable
    ETP,                       // External trigger polarity
};

/*
    slave mode control register @ 0X40000400 + 0X08
*/
struct tim3_smcr : public reg32bit<TIM3_SMCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X08, 0, 3> SMS;                  // Slave mode selection
    Property<0X40000400 + 0X08, 4, 3> TS;                   // Trigger selection
    Property<0X40000400 + 0X08, 7, 1> MSM;                  // Master/Slave mode
    Property<0X40000400 + 0X08, 8, 4> ETF;                  // External trigger filter
    Property<0X40000400 + 0X08, 12, 2> ETPS;                // External trigger prescaler
    Property<0X40000400 + 0X08, 14, 1> ECE;                 // External clock enable
    Property<0X40000400 + 0X08, 15, 1> ETP;                 // External trigger polarity
};


enum class TIM3_DIER
{
    UIE,                       // Update interrupt enable
    CC1IE,                     // Capture/Compare 1 interrupt enable
    CC2IE,                     // Capture/Compare 2 interrupt enable
    CC3IE,                     // Capture/Compare 3 interrupt enable
    CC4IE,                     // Capture/Compare 4 interrupt enable
    TIE = 6,                   // Trigger interrupt enable
    UDE = 8,                   // Update DMA request enable
    CC1DE,                     // Capture/Compare 1 DMA request enable
    CC2DE,                     // Capture/Compare 2 DMA request enable
    CC3DE,                     // Capture/Compare 3 DMA request enable
    CC4DE,                     // Capture/Compare 4 DMA request enable
    COMDE,                     // Reserved
    TDE,                       // Trigger DMA request enable
};

/*
    DMA/Interrupt enable register @ 0X40000400 + 0X0C
*/
struct tim3_dier : public reg32bit<TIM3_DIER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X0C, 0, 1> UIE;                  // Update interrupt enable
    Property<0X40000400 + 0X0C, 1, 1> CC1IE;                // Capture/Compare 1 interrupt enable
    Property<0X40000400 + 0X0C, 2, 1> CC2IE;                // Capture/Compare 2 interrupt enable
    Property<0X40000400 + 0X0C, 3, 1> CC3IE;                // Capture/Compare 3 interrupt enable
    Property<0X40000400 + 0X0C, 4, 1> CC4IE;                // Capture/Compare 4 interrupt enable
    Property<0X40000400 + 0X0C, 6, 1> TIE;                  // Trigger interrupt enable
    Property<0X40000400 + 0X0C, 8, 1> UDE;                  // Update DMA request enable
    Property<0X40000400 + 0X0C, 9, 1> CC1DE;                // Capture/Compare 1 DMA request enable
    Property<0X40000400 + 0X0C, 10, 1> CC2DE;               // Capture/Compare 2 DMA request enable
    Property<0X40000400 + 0X0C, 11, 1> CC3DE;               // Capture/Compare 3 DMA request enable
    Property<0X40000400 + 0X0C, 12, 1> CC4DE;               // Capture/Compare 4 DMA request enable
    Property<0X40000400 + 0X0C, 13, 1> COMDE;               // Reserved
    Property<0X40000400 + 0X0C, 14, 1> TDE;                 // Trigger DMA request enable
};


enum class TIM3_SR
{
    UIF,                       // Update interrupt flag
    CC1IF,                     // Capture/compare 1 interrupt flag
    CC2IF,                     // Capture/Compare 2 interrupt flag
    CC3IF,                     // Capture/Compare 3 interrupt flag
    CC4IF,                     // Capture/Compare 4 interrupt flag
    TIF = 6,                   // Trigger interrupt flag
    CC1OF = 9,                 // Capture/Compare 1 overcapture flag
    CC2OF,                     // Capture/compare 2 overcapture flag
    CC3OF,                     // Capture/Compare 3 overcapture flag
    CC4OF,                     // Capture/Compare 4 overcapture flag
};

/*
    status register @ 0X40000400 + 0X10
*/
struct tim3_sr : public reg32bit<TIM3_SR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X10, 0, 1> UIF;                  // Update interrupt flag
    Property<0X40000400 + 0X10, 1, 1> CC1IF;                // Capture/compare 1 interrupt flag
    Property<0X40000400 + 0X10, 2, 1> CC2IF;                // Capture/Compare 2 interrupt flag
    Property<0X40000400 + 0X10, 3, 1> CC3IF;                // Capture/Compare 3 interrupt flag
    Property<0X40000400 + 0X10, 4, 1> CC4IF;                // Capture/Compare 4 interrupt flag
    Property<0X40000400 + 0X10, 6, 1> TIF;                  // Trigger interrupt flag
    Property<0X40000400 + 0X10, 9, 1> CC1OF;                // Capture/Compare 1 overcapture flag
    Property<0X40000400 + 0X10, 10, 1> CC2OF;               // Capture/compare 2 overcapture flag
    Property<0X40000400 + 0X10, 11, 1> CC3OF;               // Capture/Compare 3 overcapture flag
    Property<0X40000400 + 0X10, 12, 1> CC4OF;               // Capture/Compare 4 overcapture flag
};


enum class TIM3_EGR
{
    UG,                        // Update generation
    CC1G,                      // Capture/compare 1 generation
    CC2G,                      // Capture/compare 2 generation
    CC3G,                      // Capture/compare 3 generation
    CC4G,                      // Capture/compare 4 generation
    TG = 6,                    // Trigger generation
};

/*
    event generation register @ 0X40000400 + 0X14
*/
struct tim3_egr : public reg32bit<TIM3_EGR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X14, 0, 1> UG;                   // Update generation
    Property<0X40000400 + 0X14, 1, 1> CC1G;                 // Capture/compare 1 generation
    Property<0X40000400 + 0X14, 2, 1> CC2G;                 // Capture/compare 2 generation
    Property<0X40000400 + 0X14, 3, 1> CC3G;                 // Capture/compare 3 generation
    Property<0X40000400 + 0X14, 4, 1> CC4G;                 // Capture/compare 4 generation
    Property<0X40000400 + 0X14, 6, 1> TG;                   // Trigger generation
};


enum class TIM3_CCMR1_Output
{
    CC1S,                      // Capture/Compare 1 selection
    OC1FE = 2,                 // Output compare 1 fast enable
    OC1PE,                     // Output compare 1 preload enable
    OC1M,                      // Output compare 1 mode
    OC1CE = 7,                 // Output compare 1 clear enable
    CC2S,                      // Capture/Compare 2 selection
    OC2FE = 10,                // Output compare 2 fast enable
    OC2PE,                     // Output compare 2 preload enable
    OC2M,                      // Output compare 2 mode
    OC2CE = 15,                // Output compare 2 clear enable
};

/*
    capture/compare mode register 1 (output mode) @ 0X40000400 + 0X18
*/
struct tim3_ccmr1_output : public reg32bit<TIM3_CCMR1_Output>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40000400 + 0X18, 2, 1> OC1FE;                // Output compare 1 fast enable
    Property<0X40000400 + 0X18, 3, 1> OC1PE;                // Output compare 1 preload enable
    Property<0X40000400 + 0X18, 4, 3> OC1M;                 // Output compare 1 mode
    Property<0X40000400 + 0X18, 7, 1> OC1CE;                // Output compare 1 clear enable
    Property<0X40000400 + 0X18, 8, 2> CC2S;                 // Capture/Compare 2 selection
    Property<0X40000400 + 0X18, 10, 1> OC2FE;               // Output compare 2 fast enable
    Property<0X40000400 + 0X18, 11, 1> OC2PE;               // Output compare 2 preload enable
    Property<0X40000400 + 0X18, 12, 3> OC2M;                // Output compare 2 mode
    Property<0X40000400 + 0X18, 15, 1> OC2CE;               // Output compare 2 clear enable
};


enum class TIM3_CCMR1_Input
{
    CC1S,                      // Capture/Compare 1 selection
    IC1PSC = 2,                // Input capture 1 prescaler
    IC1F = 4,                  // Input capture 1 filter
    CC2S = 8,                  // Capture/compare 2 selection
    IC2PSC = 10,               // Input capture 2 prescaler
    IC2F = 12,                 // Input capture 2 filter
};

/*
    capture/compare mode register 1 (input mode) @ 0X40000400 + 0X18
*/
struct tim3_ccmr1_input : public reg32bit<TIM3_CCMR1_Input>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X18, 0, 2> CC1S;                 // Capture/Compare 1 selection
    Property<0X40000400 + 0X18, 2, 2> IC1PSC;               // Input capture 1 prescaler
    Property<0X40000400 + 0X18, 4, 4> IC1F;                 // Input capture 1 filter
    Property<0X40000400 + 0X18, 8, 2> CC2S;                 // Capture/compare 2 selection
    Property<0X40000400 + 0X18, 10, 2> IC2PSC;              // Input capture 2 prescaler
    Property<0X40000400 + 0X18, 12, 4> IC2F;                // Input capture 2 filter
};


enum class TIM3_CCMR2_Output
{
    CC3S,                      // Capture/Compare 3 selection
    OC3FE = 2,                 // Output compare 3 fast enable
    OC3PE,                     // Output compare 3 preload enable
    OC3M,                      // Output compare 3 mode
    OC3CE = 7,                 // Output compare 3 clear enable
    CC4S,                      // Capture/Compare 4 selection
    OC4FE = 10,                // Output compare 4 fast enable
    OC4PE,                     // Output compare 4 preload enable
    OC4M,                      // Output compare 4 mode
    OC4CE = 15,                // Output compare 4 clear enable
};

/*
    capture/compare mode register 2 (output mode) @ 0X40000400 + 0X1C
*/
struct tim3_ccmr2_output : public reg32bit<TIM3_CCMR2_Output>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X1C, 0, 2> CC3S;                 // Capture/Compare 3 selection
    Property<0X40000400 + 0X1C, 2, 1> OC3FE;                // Output compare 3 fast enable
    Property<0X40000400 + 0X1C, 3, 1> OC3PE;                // Output compare 3 preload enable
    Property<0X40000400 + 0X1C, 4, 3> OC3M;                 // Output compare 3 mode
    Property<0X40000400 + 0X1C, 7, 1> OC3CE;                // Output compare 3 clear enable
    Property<0X40000400 + 0X1C, 8, 2> CC4S;                 // Capture/Compare 4 selection
    Property<0X40000400 + 0X1C, 10, 1> OC4FE;               // Output compare 4 fast enable
    Property<0X40000400 + 0X1C, 11, 1> OC4PE;               // Output compare 4 preload enable
    Property<0X40000400 + 0X1C, 12, 3> OC4M;                // Output compare 4 mode
    Property<0X40000400 + 0X1C, 15, 1> OC4CE;               // Output compare 4 clear enable
};


enum class TIM3_CCMR2_Input
{
    CC3S,                      // Capture/Compare 3 selection
    IC3PSC = 2,                // Input capture 3 prescaler
    IC3F = 4,                  // Input capture 3 filter
    CC4S = 8,                  // Capture/Compare 4 selection
    IC4PSC = 10,               // Input capture 4 prescaler
    IC4F = 12,                 // Input capture 4 filter
};

/*
    capture/compare mode register 2 (input mode) @ 0X40000400 + 0X1C
*/
struct tim3_ccmr2_input : public reg32bit<TIM3_CCMR2_Input>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X1C, 0, 2> CC3S;                 // Capture/Compare 3 selection
    Property<0X40000400 + 0X1C, 2, 2> IC3PSC;               // Input capture 3 prescaler
    Property<0X40000400 + 0X1C, 4, 4> IC3F;                 // Input capture 3 filter
    Property<0X40000400 + 0X1C, 8, 2> CC4S;                 // Capture/Compare 4 selection
    Property<0X40000400 + 0X1C, 10, 2> IC4PSC;              // Input capture 4 prescaler
    Property<0X40000400 + 0X1C, 12, 4> IC4F;                // Input capture 4 filter
};


enum class TIM3_CCER
{
    CC1E,                      // Capture/Compare 1 output enable
    CC1P,                      // Capture/Compare 1 output Polarity
    CC1NP = 3,                 // Capture/Compare 1 output Polarity
    CC2E,                      // Capture/Compare 2 output enable
    CC2P,                      // Capture/Compare 2 output Polarity
    CC2NP = 7,                 // Capture/Compare 2 output Polarity
    CC3E,                      // Capture/Compare 3 output enable
    CC3P,                      // Capture/Compare 3 output Polarity
    CC3NP = 11,                // Capture/Compare 3 output Polarity
    CC4E,                      // Capture/Compare 4 output enable
    CC4P,                      // Capture/Compare 3 output Polarity
    CC4NP = 15,                // Capture/Compare 4 output Polarity
};

/*
    capture/compare enable register @ 0X40000400 + 0X20
*/
struct tim3_ccer : public reg32bit<TIM3_CCER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X20, 0, 1> CC1E;                 // Capture/Compare 1 output enable
    Property<0X40000400 + 0X20, 1, 1> CC1P;                 // Capture/Compare 1 output Polarity
    Property<0X40000400 + 0X20, 3, 1> CC1NP;                // Capture/Compare 1 output Polarity
    Property<0X40000400 + 0X20, 4, 1> CC2E;                 // Capture/Compare 2 output enable
    Property<0X40000400 + 0X20, 5, 1> CC2P;                 // Capture/Compare 2 output Polarity
    Property<0X40000400 + 0X20, 7, 1> CC2NP;                // Capture/Compare 2 output Polarity
    Property<0X40000400 + 0X20, 8, 1> CC3E;                 // Capture/Compare 3 output enable
    Property<0X40000400 + 0X20, 9, 1> CC3P;                 // Capture/Compare 3 output Polarity
    Property<0X40000400 + 0X20, 11, 1> CC3NP;               // Capture/Compare 3 output Polarity
    Property<0X40000400 + 0X20, 12, 1> CC4E;                // Capture/Compare 4 output enable
    Property<0X40000400 + 0X20, 13, 1> CC4P;                // Capture/Compare 3 output Polarity
    Property<0X40000400 + 0X20, 15, 1> CC4NP;               // Capture/Compare 4 output Polarity
};


enum class TIM3_CNT
{
    CNT_L,                     // Low counter value
    CNT_H = 16,                // High counter value (TIM2 only)
};

/*
    counter @ 0X40000400 + 0X24
*/
struct tim3_cnt : public reg32bit<TIM3_CNT>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X24, 0, 16> CNT_L;               // Low counter value
    Property<0X40000400 + 0X24, 16, 16> CNT_H;              // High counter value (TIM2 only)
};


enum class TIM3_ARR
{
    ARR_L,                     // Low Auto-reload value
    ARR_H = 16,                // High Auto-reload value (TIM2 only)
};

/*
    auto-reload register @ 0X40000400 + 0X2C
*/
struct tim3_arr : public reg32bit<TIM3_ARR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X2C, 0, 16> ARR_L;               // Low Auto-reload value
    Property<0X40000400 + 0X2C, 16, 16> ARR_H;              // High Auto-reload value (TIM2 only)
};


enum class TIM3_CCR1
{
    CCR1_L,                    // Low Capture/Compare 1 value
    CCR1_H = 16,               // High Capture/Compare 1 value (TIM2 only)
};

/*
    capture/compare register 1 @ 0X40000400 + 0X34
*/
struct tim3_ccr1 : public reg32bit<TIM3_CCR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X34, 0, 16> CCR1_L;              // Low Capture/Compare 1 value
    Property<0X40000400 + 0X34, 16, 16> CCR1_H;             // High Capture/Compare 1 value (TIM2 only)
};


enum class TIM3_CCR2
{
    CCR2_L,                    // Low Capture/Compare 2 value
    CCR2_H = 16,               // High Capture/Compare 2 value (TIM2 only)
};

/*
    capture/compare register 2 @ 0X40000400 + 0X38
*/
struct tim3_ccr2 : public reg32bit<TIM3_CCR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X38, 0, 16> CCR2_L;              // Low Capture/Compare 2 value
    Property<0X40000400 + 0X38, 16, 16> CCR2_H;             // High Capture/Compare 2 value (TIM2 only)
};


enum class TIM3_CCR3
{
    CCR3_L,                    // Low Capture/Compare value
    CCR3_H = 16,               // High Capture/Compare value (TIM2 only)
};

/*
    capture/compare register 3 @ 0X40000400 + 0X3C
*/
struct tim3_ccr3 : public reg32bit<TIM3_CCR3>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X3C, 0, 16> CCR3_L;              // Low Capture/Compare value
    Property<0X40000400 + 0X3C, 16, 16> CCR3_H;             // High Capture/Compare value (TIM2 only)
};


enum class TIM3_CCR4
{
    CCR4_L,                    // Low Capture/Compare value
    CCR4_H = 16,               // High Capture/Compare value (TIM2 only)
};

/*
    capture/compare register 4 @ 0X40000400 + 0X40
*/
struct tim3_ccr4 : public reg32bit<TIM3_CCR4>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X40, 0, 16> CCR4_L;              // Low Capture/Compare value
    Property<0X40000400 + 0X40, 16, 16> CCR4_H;             // High Capture/Compare value (TIM2 only)
};


enum class TIM3_DCR
{
    DBA,                       // DMA base address
    DBL = 8,                   // DMA burst length
};

/*
    DMA control register @ 0X40000400 + 0X48
*/
struct tim3_dcr : public reg32bit<TIM3_DCR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40000400 + 0X48, 0, 5> DBA;                  // DMA base address
    Property<0X40000400 + 0X48, 8, 5> DBL;                  // DMA burst length
};


/*
    General-purpose-timers @ 0X40000400
*/
struct TIM3
{
    tim3_cr1 CR1;              // control register 1
    tim3_cr2 CR2;              // control register 2
    tim3_smcr SMCR;            // slave mode control register
    tim3_dier DIER;            // DMA/Interrupt enable register
    tim3_sr SR;                // status register
    tim3_egr EGR;              // event generation register
    tim3_ccmr1_output CCMR1_Output; // capture/compare mode register 1 (output mode)
    tim3_ccmr1_input CCMR1_Input; // capture/compare mode register 1 (input mode)
    tim3_ccmr2_output CCMR2_Output; // capture/compare mode register 2 (output mode)
    tim3_ccmr2_input CCMR2_Input; // capture/compare mode register 2 (input mode)
    tim3_ccer CCER;            // capture/compare enable register
    tim3_cnt CNT;              // counter
    regrw PSC;                 // prescaler
    tim3_arr ARR;              // auto-reload register
    tim3_ccr1 CCR1;            // capture/compare register 1
    tim3_ccr2 CCR2;            // capture/compare register 2
    tim3_ccr3 CCR3;            // capture/compare register 3
    tim3_ccr4 CCR4;            // capture/compare register 4
    tim3_dcr DCR;              // DMA control register
    regrw DMAR;                // DMA address for full transfer

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40000400);}
};


enum class TIM6_CR1
{
    CEN,                       // Counter enable
    UDIS,                      // Update disable
    URS,                       // Update request source
    OPM,                       // One-pulse mode
    ARPE = 7,                  // Auto-reload preload enable
};

/*
    control register 1 @ 0X40001000 + 0X00
*/
struct tim6_cr1 : public reg32bit<TIM6_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40001000 + 0X00, 0, 1> CEN;                  // Counter enable
    Property<0X40001000 + 0X00, 1, 1> UDIS;                 // Update disable
    Property<0X40001000 + 0X00, 2, 1> URS;                  // Update request source
    Property<0X40001000 + 0X00, 3, 1> OPM;                  // One-pulse mode
    Property<0X40001000 + 0X00, 7, 1> ARPE;                 // Auto-reload preload enable
};


enum class TIM6_DIER
{
    UIE,                       // Update interrupt enable
    UDE = 8,                   // Update DMA request enable
};

/*
    DMA/Interrupt enable register @ 0X40001000 + 0X0C
*/
struct tim6_dier : public reg32bit<TIM6_DIER>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40001000 + 0X0C, 0, 1> UIE;                  // Update interrupt enable
    Property<0X40001000 + 0X0C, 8, 1> UDE;                  // Update DMA request enable
};


/*
    Basic-timers @ 0X40001000
*/
struct TIM6
{
    tim6_cr1 CR1;              // control register 1
    regrw CR2;                 // control register 2
    tim6_dier DIER;            // DMA/Interrupt enable register
    regrw SR;                  // status register
    regrw EGR;                 // event generation register
    regrw CNT;                 // counter
    regrw PSC;                 // prescaler
    regrw ARR;                 // auto-reload register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40001000);}
};


enum class USART1_CR1
{
    UE,                        // USART enable
    UESM,                      // USART enable in Stop mode
    RE,                        // Receiver enable
    TE,                        // Transmitter enable
    IDLEIE,                    // IDLE interrupt enable
    RXNEIE,                    // RXNE interrupt enable
    TCIE,                      // Transmission complete interrupt enable
    TXEIE,                     // interrupt enable
    PEIE,                      // PE interrupt enable
    PS,                        // Parity selection
    PCE,                       // Parity control enable
    WAKE,                      // Receiver wakeup method
    M,                         // Word length
    MME,                       // Mute mode enable
    CMIE,                      // Character match interrupt enable
    OVER8,                     // Oversampling mode
    DEDT,                      // Driver Enable deassertion time
    DEAT = 21,                 // Driver Enable assertion time
    RTOIE = 26,                // Receiver timeout interrupt enable
    EOBIE,                     // End of Block interrupt enable
    M1,                        // Word length
};

/*
    Control register 1 @ 0X40013800 + 0X00
*/
struct usart1_cr1 : public reg32bit<USART1_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X00, 0, 1> UE;                   // USART enable
    Property<0X40013800 + 0X00, 1, 1> UESM;                 // USART enable in Stop mode
    Property<0X40013800 + 0X00, 2, 1> RE;                   // Receiver enable
    Property<0X40013800 + 0X00, 3, 1> TE;                   // Transmitter enable
    Property<0X40013800 + 0X00, 4, 1> IDLEIE;               // IDLE interrupt enable
    Property<0X40013800 + 0X00, 5, 1> RXNEIE;               // RXNE interrupt enable
    Property<0X40013800 + 0X00, 6, 1> TCIE;                 // Transmission complete interrupt enable
    Property<0X40013800 + 0X00, 7, 1> TXEIE;                // interrupt enable
    Property<0X40013800 + 0X00, 8, 1> PEIE;                 // PE interrupt enable
    Property<0X40013800 + 0X00, 9, 1> PS;                   // Parity selection
    Property<0X40013800 + 0X00, 10, 1> PCE;                 // Parity control enable
    Property<0X40013800 + 0X00, 11, 1> WAKE;                // Receiver wakeup method
    Property<0X40013800 + 0X00, 12, 1> M;                   // Word length
    Property<0X40013800 + 0X00, 13, 1> MME;                 // Mute mode enable
    Property<0X40013800 + 0X00, 14, 1> CMIE;                // Character match interrupt enable
    Property<0X40013800 + 0X00, 15, 1> OVER8;               // Oversampling mode
    Property<0X40013800 + 0X00, 16, 5> DEDT;                // Driver Enable deassertion time
    Property<0X40013800 + 0X00, 21, 5> DEAT;                // Driver Enable assertion time
    Property<0X40013800 + 0X00, 26, 1> RTOIE;               // Receiver timeout interrupt enable
    Property<0X40013800 + 0X00, 27, 1> EOBIE;               // End of Block interrupt enable
    Property<0X40013800 + 0X00, 28, 1> M1;                  // Word length
};


enum class USART1_CR2
{
    ADDM7 = 4,                 // 7-bit Address Detection/4-bit Address Detection
    LBDL,                      // LIN break detection length
    LBDIE,                     // LIN break detection interrupt enable
    LBCL = 8,                  // Last bit clock pulse
    CPHA,                      // Clock phase
    CPOL,                      // Clock polarity
    CLKEN,                     // Clock enable
    STOP,                      // STOP bits
    LINEN = 14,                // LIN mode enable
    SWAP,                      // Swap TX/RX pins
    RXINV,                     // RX pin active level inversion
    TXINV,                     // TX pin active level inversion
    DATAINV,                   // Binary data inversion
    MSBFIRST,                  // Most significant bit first
    ABREN,                     // Auto baud rate enable
    ABRMOD,                    // Auto baud rate mode
    RTOEN = 23,                // Receiver timeout enable
    ADD0,                      // Address of the USART node
    ADD4 = 28,                 // Address of the USART node
};

/*
    Control register 2 @ 0X40013800 + 0X04
*/
struct usart1_cr2 : public reg32bit<USART1_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X04, 4, 1> ADDM7;                // 7-bit Address Detection/4-bit Address Detection
    Property<0X40013800 + 0X04, 5, 1> LBDL;                 // LIN break detection length
    Property<0X40013800 + 0X04, 6, 1> LBDIE;                // LIN break detection interrupt enable
    Property<0X40013800 + 0X04, 8, 1> LBCL;                 // Last bit clock pulse
    Property<0X40013800 + 0X04, 9, 1> CPHA;                 // Clock phase
    Property<0X40013800 + 0X04, 10, 1> CPOL;                // Clock polarity
    Property<0X40013800 + 0X04, 11, 1> CLKEN;               // Clock enable
    Property<0X40013800 + 0X04, 12, 2> STOP;                // STOP bits
    Property<0X40013800 + 0X04, 14, 1> LINEN;               // LIN mode enable
    Property<0X40013800 + 0X04, 15, 1> SWAP;                // Swap TX/RX pins
    Property<0X40013800 + 0X04, 16, 1> RXINV;               // RX pin active level inversion
    Property<0X40013800 + 0X04, 17, 1> TXINV;               // TX pin active level inversion
    Property<0X40013800 + 0X04, 18, 1> DATAINV;             // Binary data inversion
    Property<0X40013800 + 0X04, 19, 1> MSBFIRST;            // Most significant bit first
    Property<0X40013800 + 0X04, 20, 1> ABREN;               // Auto baud rate enable
    Property<0X40013800 + 0X04, 21, 2> ABRMOD;              // Auto baud rate mode
    Property<0X40013800 + 0X04, 23, 1> RTOEN;               // Receiver timeout enable
    Property<0X40013800 + 0X04, 24, 4> ADD0;                // Address of the USART node
    Property<0X40013800 + 0X04, 28, 4> ADD4;                // Address of the USART node
};


enum class USART1_CR3
{
    EIE,                       // Error interrupt enable
    IREN,                      // IrDA mode enable
    IRLP,                      // IrDA low-power
    HDSEL,                     // Half-duplex selection
    NACK,                      // Smartcard NACK enable
    SCEN,                      // Smartcard mode enable
    DMAR,                      // DMA enable receiver
    DMAT,                      // DMA enable transmitter
    RTSE,                      // RTS enable
    CTSE,                      // CTS enable
    CTSIE,                     // CTS interrupt enable
    ONEBIT,                    // One sample bit method enable
    OVRDIS,                    // Overrun Disable
    DDRE,                      // DMA Disable on Reception Error
    DEM,                       // Driver enable mode
    DEP,                       // Driver enable polarity selection
    SCARCNT = 17,              // Smartcard auto-retry count
    WUS = 20,                  // Wakeup from Stop mode interrupt flag selection
    WUFIE = 22,                // Wakeup from Stop mode interrupt enable
};

/*
    Control register 3 @ 0X40013800 + 0X08
*/
struct usart1_cr3 : public reg32bit<USART1_CR3>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X08, 0, 1> EIE;                  // Error interrupt enable
    Property<0X40013800 + 0X08, 1, 1> IREN;                 // IrDA mode enable
    Property<0X40013800 + 0X08, 2, 1> IRLP;                 // IrDA low-power
    Property<0X40013800 + 0X08, 3, 1> HDSEL;                // Half-duplex selection
    Property<0X40013800 + 0X08, 4, 1> NACK;                 // Smartcard NACK enable
    Property<0X40013800 + 0X08, 5, 1> SCEN;                 // Smartcard mode enable
    Property<0X40013800 + 0X08, 6, 1> DMAR;                 // DMA enable receiver
    Property<0X40013800 + 0X08, 7, 1> DMAT;                 // DMA enable transmitter
    Property<0X40013800 + 0X08, 8, 1> RTSE;                 // RTS enable
    Property<0X40013800 + 0X08, 9, 1> CTSE;                 // CTS enable
    Property<0X40013800 + 0X08, 10, 1> CTSIE;               // CTS interrupt enable
    Property<0X40013800 + 0X08, 11, 1> ONEBIT;              // One sample bit method enable
    Property<0X40013800 + 0X08, 12, 1> OVRDIS;              // Overrun Disable
    Property<0X40013800 + 0X08, 13, 1> DDRE;                // DMA Disable on Reception Error
    Property<0X40013800 + 0X08, 14, 1> DEM;                 // Driver enable mode
    Property<0X40013800 + 0X08, 15, 1> DEP;                 // Driver enable polarity selection
    Property<0X40013800 + 0X08, 17, 3> SCARCNT;             // Smartcard auto-retry count
    Property<0X40013800 + 0X08, 20, 2> WUS;                 // Wakeup from Stop mode interrupt flag selection
    Property<0X40013800 + 0X08, 22, 1> WUFIE;               // Wakeup from Stop mode interrupt enable
};


enum class USART1_BRR
{
    DIV_Fraction,              // fraction of USARTDIV
    DIV_Mantissa = 4,          // mantissa of USARTDIV
};

/*
    Baud rate register @ 0X40013800 + 0X0C
*/
struct usart1_brr : public reg32bit<USART1_BRR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X0C, 0, 4> DIV_Fraction;         // fraction of USARTDIV
    Property<0X40013800 + 0X0C, 4, 12> DIV_Mantissa;        // mantissa of USARTDIV
};


enum class USART1_GTPR
{
    PSC,                       // Prescaler value
    GT = 8,                    // Guard time value
};

/*
    Guard time and prescaler register @ 0X40013800 + 0X10
*/
struct usart1_gtpr : public reg32bit<USART1_GTPR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X10, 0, 8> PSC;                  // Prescaler value
    Property<0X40013800 + 0X10, 8, 8> GT;                   // Guard time value
};


enum class USART1_RTOR
{
    RTO,                       // Receiver timeout value
    BLEN = 24,                 // Block Length
};

/*
    Receiver timeout register @ 0X40013800 + 0X14
*/
struct usart1_rtor : public reg32bit<USART1_RTOR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X14, 0, 24> RTO;                 // Receiver timeout value
    Property<0X40013800 + 0X14, 24, 8> BLEN;                // Block Length
};


enum class USART1_RQR
{
    ABRRQ,                     // Auto baud rate request
    SBKRQ,                     // Send break request
    MMRQ,                      // Mute mode request
    RXFRQ,                     // Receive data flush request
    TXFRQ,                     // Transmit data flush request
};

/*
    Request register @ 0X40013800 + 0X18
*/
struct usart1_rqr : public reg32bit<USART1_RQR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X18, 0, 1> ABRRQ;                // Auto baud rate request
    Property<0X40013800 + 0X18, 1, 1> SBKRQ;                // Send break request
    Property<0X40013800 + 0X18, 2, 1> MMRQ;                 // Mute mode request
    Property<0X40013800 + 0X18, 3, 1> RXFRQ;                // Receive data flush request
    Property<0X40013800 + 0X18, 4, 1> TXFRQ;                // Transmit data flush request
};


enum class USART1_ISR
{
    PE,                        // Parity error
    FE,                        // Framing error
    NF,                        // Noise detected flag
    ORE,                       // Overrun error
    IDLE,                      // Idle line detected
    RXNE,                      // Read data register not empty
    TC,                        // Transmission complete
    TXE,                       // Transmit data register empty
    LBDF,                      // LIN break detection flag
    CTSIF,                     // CTS interrupt flag
    CTS,                       // CTS flag
    RTOF,                      // Receiver timeout
    EOBF,                      // End of block flag
    ABRE = 14,                 // Auto baud rate error
    ABRF,                      // Auto baud rate flag
    BUSY,                      // Busy flag
    CMF,                       // character match flag
    SBKF,                      // Send break flag
    RWU,                       // Receiver wakeup from Mute mode
    WUF,                       // Wakeup from Stop mode flag
    TEACK,                     // Transmit enable acknowledge flag
    REACK,                     // Receive enable acknowledge flag
};

/*
    Interrupt & status register @ 0X40013800 + 0X1C
*/
struct usart1_isr : public reg32bit<USART1_ISR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X1C, 0, 1> PE;                   // Parity error
    Property<0X40013800 + 0X1C, 1, 1> FE;                   // Framing error
    Property<0X40013800 + 0X1C, 2, 1> NF;                   // Noise detected flag
    Property<0X40013800 + 0X1C, 3, 1> ORE;                  // Overrun error
    Property<0X40013800 + 0X1C, 4, 1> IDLE;                 // Idle line detected
    Property<0X40013800 + 0X1C, 5, 1> RXNE;                 // Read data register not empty
    Property<0X40013800 + 0X1C, 6, 1> TC;                   // Transmission complete
    Property<0X40013800 + 0X1C, 7, 1> TXE;                  // Transmit data register empty
    Property<0X40013800 + 0X1C, 8, 1> LBDF;                 // LIN break detection flag
    Property<0X40013800 + 0X1C, 9, 1> CTSIF;                // CTS interrupt flag
    Property<0X40013800 + 0X1C, 10, 1> CTS;                 // CTS flag
    Property<0X40013800 + 0X1C, 11, 1> RTOF;                // Receiver timeout
    Property<0X40013800 + 0X1C, 12, 1> EOBF;                // End of block flag
    Property<0X40013800 + 0X1C, 14, 1> ABRE;                // Auto baud rate error
    Property<0X40013800 + 0X1C, 15, 1> ABRF;                // Auto baud rate flag
    Property<0X40013800 + 0X1C, 16, 1> BUSY;                // Busy flag
    Property<0X40013800 + 0X1C, 17, 1> CMF;                 // character match flag
    Property<0X40013800 + 0X1C, 18, 1> SBKF;                // Send break flag
    Property<0X40013800 + 0X1C, 19, 1> RWU;                 // Receiver wakeup from Mute mode
    Property<0X40013800 + 0X1C, 20, 1> WUF;                 // Wakeup from Stop mode flag
    Property<0X40013800 + 0X1C, 21, 1> TEACK;               // Transmit enable acknowledge flag
    Property<0X40013800 + 0X1C, 22, 1> REACK;               // Receive enable acknowledge flag
};


enum class USART1_ICR
{
    PECF,                      // Parity error clear flag
    FECF,                      // Framing error clear flag
    NCF,                       // Noise detected clear flag
    ORECF,                     // Overrun error clear flag
    IDLECF,                    // Idle line detected clear flag
    TCCF = 6,                  // Transmission complete clear flag
    LBDCF = 8,                 // LIN break detection clear flag
    CTSCF,                     // CTS clear flag
    RTOCF = 11,                // Receiver timeout clear flag
    EOBCF,                     // End of timeout clear flag
    CMCF = 17,                 // Character match clear flag
    WUCF = 20,                 // Wakeup from Stop mode clear flag
};

/*
    Interrupt flag clear register @ 0X40013800 + 0X20
*/
struct usart1_icr : public reg32bit<USART1_ICR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40013800 + 0X20, 0, 1> PECF;                 // Parity error clear flag
    Property<0X40013800 + 0X20, 1, 1> FECF;                 // Framing error clear flag
    Property<0X40013800 + 0X20, 2, 1> NCF;                  // Noise detected clear flag
    Property<0X40013800 + 0X20, 3, 1> ORECF;                // Overrun error clear flag
    Property<0X40013800 + 0X20, 4, 1> IDLECF;               // Idle line detected clear flag
    Property<0X40013800 + 0X20, 6, 1> TCCF;                 // Transmission complete clear flag
    Property<0X40013800 + 0X20, 8, 1> LBDCF;                // LIN break detection clear flag
    Property<0X40013800 + 0X20, 9, 1> CTSCF;                // CTS clear flag
    Property<0X40013800 + 0X20, 11, 1> RTOCF;               // Receiver timeout clear flag
    Property<0X40013800 + 0X20, 12, 1> EOBCF;               // End of timeout clear flag
    Property<0X40013800 + 0X20, 17, 1> CMCF;                // Character match clear flag
    Property<0X40013800 + 0X20, 20, 1> WUCF;                // Wakeup from Stop mode clear flag
};


/*
    Universal synchronous asynchronous receiver transmitter @ 0X40013800
*/
struct USART1
{
    usart1_cr1 CR1;            // Control register 1
    usart1_cr2 CR2;            // Control register 2
    usart1_cr3 CR3;            // Control register 3
    usart1_brr BRR;            // Baud rate register
    usart1_gtpr GTPR;          // Guard time and prescaler register
    usart1_rtor RTOR;          // Receiver timeout register
    usart1_rqr RQR;            // Request register
    usart1_isr ISR;            // Interrupt & status register
    usart1_icr ICR;            // Interrupt flag clear register
    regrw RDR;                 // Receive data register
    regrw TDR;                 // Transmit data register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40013800);}
};


enum class USART2_CR1
{
    UE,                        // USART enable
    UESM,                      // USART enable in Stop mode
    RE,                        // Receiver enable
    TE,                        // Transmitter enable
    IDLEIE,                    // IDLE interrupt enable
    RXNEIE,                    // RXNE interrupt enable
    TCIE,                      // Transmission complete interrupt enable
    TXEIE,                     // interrupt enable
    PEIE,                      // PE interrupt enable
    PS,                        // Parity selection
    PCE,                       // Parity control enable
    WAKE,                      // Receiver wakeup method
    M,                         // Word length
    MME,                       // Mute mode enable
    CMIE,                      // Character match interrupt enable
    OVER8,                     // Oversampling mode
    DEDT,                      // Driver Enable deassertion time
    DEAT = 21,                 // Driver Enable assertion time
    RTOIE = 26,                // Receiver timeout interrupt enable
    EOBIE,                     // End of Block interrupt enable
    M1,                        // Word length
};

/*
    Control register 1 @ 0X40004400 + 0X00
*/
struct usart2_cr1 : public reg32bit<USART2_CR1>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X00, 0, 1> UE;                   // USART enable
    Property<0X40004400 + 0X00, 1, 1> UESM;                 // USART enable in Stop mode
    Property<0X40004400 + 0X00, 2, 1> RE;                   // Receiver enable
    Property<0X40004400 + 0X00, 3, 1> TE;                   // Transmitter enable
    Property<0X40004400 + 0X00, 4, 1> IDLEIE;               // IDLE interrupt enable
    Property<0X40004400 + 0X00, 5, 1> RXNEIE;               // RXNE interrupt enable
    Property<0X40004400 + 0X00, 6, 1> TCIE;                 // Transmission complete interrupt enable
    Property<0X40004400 + 0X00, 7, 1> TXEIE;                // interrupt enable
    Property<0X40004400 + 0X00, 8, 1> PEIE;                 // PE interrupt enable
    Property<0X40004400 + 0X00, 9, 1> PS;                   // Parity selection
    Property<0X40004400 + 0X00, 10, 1> PCE;                 // Parity control enable
    Property<0X40004400 + 0X00, 11, 1> WAKE;                // Receiver wakeup method
    Property<0X40004400 + 0X00, 12, 1> M;                   // Word length
    Property<0X40004400 + 0X00, 13, 1> MME;                 // Mute mode enable
    Property<0X40004400 + 0X00, 14, 1> CMIE;                // Character match interrupt enable
    Property<0X40004400 + 0X00, 15, 1> OVER8;               // Oversampling mode
    Property<0X40004400 + 0X00, 16, 5> DEDT;                // Driver Enable deassertion time
    Property<0X40004400 + 0X00, 21, 5> DEAT;                // Driver Enable assertion time
    Property<0X40004400 + 0X00, 26, 1> RTOIE;               // Receiver timeout interrupt enable
    Property<0X40004400 + 0X00, 27, 1> EOBIE;               // End of Block interrupt enable
    Property<0X40004400 + 0X00, 28, 1> M1;                  // Word length
};


enum class USART2_CR2
{
    ADDM7 = 4,                 // 7-bit Address Detection/4-bit Address Detection
    LBDL,                      // LIN break detection length
    LBDIE,                     // LIN break detection interrupt enable
    LBCL = 8,                  // Last bit clock pulse
    CPHA,                      // Clock phase
    CPOL,                      // Clock polarity
    CLKEN,                     // Clock enable
    STOP,                      // STOP bits
    LINEN = 14,                // LIN mode enable
    SWAP,                      // Swap TX/RX pins
    RXINV,                     // RX pin active level inversion
    TXINV,                     // TX pin active level inversion
    DATAINV,                   // Binary data inversion
    MSBFIRST,                  // Most significant bit first
    ABREN,                     // Auto baud rate enable
    ABRMOD,                    // Auto baud rate mode
    RTOEN = 23,                // Receiver timeout enable
    ADD0,                      // Address of the USART node
    ADD4 = 28,                 // Address of the USART node
};

/*
    Control register 2 @ 0X40004400 + 0X04
*/
struct usart2_cr2 : public reg32bit<USART2_CR2>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X04, 4, 1> ADDM7;                // 7-bit Address Detection/4-bit Address Detection
    Property<0X40004400 + 0X04, 5, 1> LBDL;                 // LIN break detection length
    Property<0X40004400 + 0X04, 6, 1> LBDIE;                // LIN break detection interrupt enable
    Property<0X40004400 + 0X04, 8, 1> LBCL;                 // Last bit clock pulse
    Property<0X40004400 + 0X04, 9, 1> CPHA;                 // Clock phase
    Property<0X40004400 + 0X04, 10, 1> CPOL;                // Clock polarity
    Property<0X40004400 + 0X04, 11, 1> CLKEN;               // Clock enable
    Property<0X40004400 + 0X04, 12, 2> STOP;                // STOP bits
    Property<0X40004400 + 0X04, 14, 1> LINEN;               // LIN mode enable
    Property<0X40004400 + 0X04, 15, 1> SWAP;                // Swap TX/RX pins
    Property<0X40004400 + 0X04, 16, 1> RXINV;               // RX pin active level inversion
    Property<0X40004400 + 0X04, 17, 1> TXINV;               // TX pin active level inversion
    Property<0X40004400 + 0X04, 18, 1> DATAINV;             // Binary data inversion
    Property<0X40004400 + 0X04, 19, 1> MSBFIRST;            // Most significant bit first
    Property<0X40004400 + 0X04, 20, 1> ABREN;               // Auto baud rate enable
    Property<0X40004400 + 0X04, 21, 2> ABRMOD;              // Auto baud rate mode
    Property<0X40004400 + 0X04, 23, 1> RTOEN;               // Receiver timeout enable
    Property<0X40004400 + 0X04, 24, 4> ADD0;                // Address of the USART node
    Property<0X40004400 + 0X04, 28, 4> ADD4;                // Address of the USART node
};


enum class USART2_CR3
{
    EIE,                       // Error interrupt enable
    IREN,                      // IrDA mode enable
    IRLP,                      // IrDA low-power
    HDSEL,                     // Half-duplex selection
    NACK,                      // Smartcard NACK enable
    SCEN,                      // Smartcard mode enable
    DMAR,                      // DMA enable receiver
    DMAT,                      // DMA enable transmitter
    RTSE,                      // RTS enable
    CTSE,                      // CTS enable
    CTSIE,                     // CTS interrupt enable
    ONEBIT,                    // One sample bit method enable
    OVRDIS,                    // Overrun Disable
    DDRE,                      // DMA Disable on Reception Error
    DEM,                       // Driver enable mode
    DEP,                       // Driver enable polarity selection
    SCARCNT = 17,              // Smartcard auto-retry count
    WUS = 20,                  // Wakeup from Stop mode interrupt flag selection
    WUFIE = 22,                // Wakeup from Stop mode interrupt enable
};

/*
    Control register 3 @ 0X40004400 + 0X08
*/
struct usart2_cr3 : public reg32bit<USART2_CR3>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X08, 0, 1> EIE;                  // Error interrupt enable
    Property<0X40004400 + 0X08, 1, 1> IREN;                 // IrDA mode enable
    Property<0X40004400 + 0X08, 2, 1> IRLP;                 // IrDA low-power
    Property<0X40004400 + 0X08, 3, 1> HDSEL;                // Half-duplex selection
    Property<0X40004400 + 0X08, 4, 1> NACK;                 // Smartcard NACK enable
    Property<0X40004400 + 0X08, 5, 1> SCEN;                 // Smartcard mode enable
    Property<0X40004400 + 0X08, 6, 1> DMAR;                 // DMA enable receiver
    Property<0X40004400 + 0X08, 7, 1> DMAT;                 // DMA enable transmitter
    Property<0X40004400 + 0X08, 8, 1> RTSE;                 // RTS enable
    Property<0X40004400 + 0X08, 9, 1> CTSE;                 // CTS enable
    Property<0X40004400 + 0X08, 10, 1> CTSIE;               // CTS interrupt enable
    Property<0X40004400 + 0X08, 11, 1> ONEBIT;              // One sample bit method enable
    Property<0X40004400 + 0X08, 12, 1> OVRDIS;              // Overrun Disable
    Property<0X40004400 + 0X08, 13, 1> DDRE;                // DMA Disable on Reception Error
    Property<0X40004400 + 0X08, 14, 1> DEM;                 // Driver enable mode
    Property<0X40004400 + 0X08, 15, 1> DEP;                 // Driver enable polarity selection
    Property<0X40004400 + 0X08, 17, 3> SCARCNT;             // Smartcard auto-retry count
    Property<0X40004400 + 0X08, 20, 2> WUS;                 // Wakeup from Stop mode interrupt flag selection
    Property<0X40004400 + 0X08, 22, 1> WUFIE;               // Wakeup from Stop mode interrupt enable
};


enum class USART2_BRR
{
    DIV_Fraction,              // fraction of USARTDIV
    DIV_Mantissa = 4,          // mantissa of USARTDIV
};

/*
    Baud rate register @ 0X40004400 + 0X0C
*/
struct usart2_brr : public reg32bit<USART2_BRR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X0C, 0, 4> DIV_Fraction;         // fraction of USARTDIV
    Property<0X40004400 + 0X0C, 4, 12> DIV_Mantissa;        // mantissa of USARTDIV
};


enum class USART2_GTPR
{
    PSC,                       // Prescaler value
    GT = 8,                    // Guard time value
};

/*
    Guard time and prescaler register @ 0X40004400 + 0X10
*/
struct usart2_gtpr : public reg32bit<USART2_GTPR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X10, 0, 8> PSC;                  // Prescaler value
    Property<0X40004400 + 0X10, 8, 8> GT;                   // Guard time value
};


enum class USART2_RTOR
{
    RTO,                       // Receiver timeout value
    BLEN = 24,                 // Block Length
};

/*
    Receiver timeout register @ 0X40004400 + 0X14
*/
struct usart2_rtor : public reg32bit<USART2_RTOR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X14, 0, 24> RTO;                 // Receiver timeout value
    Property<0X40004400 + 0X14, 24, 8> BLEN;                // Block Length
};


enum class USART2_RQR
{
    ABRRQ,                     // Auto baud rate request
    SBKRQ,                     // Send break request
    MMRQ,                      // Mute mode request
    RXFRQ,                     // Receive data flush request
    TXFRQ,                     // Transmit data flush request
};

/*
    Request register @ 0X40004400 + 0X18
*/
struct usart2_rqr : public reg32bit<USART2_RQR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X18, 0, 1> ABRRQ;                // Auto baud rate request
    Property<0X40004400 + 0X18, 1, 1> SBKRQ;                // Send break request
    Property<0X40004400 + 0X18, 2, 1> MMRQ;                 // Mute mode request
    Property<0X40004400 + 0X18, 3, 1> RXFRQ;                // Receive data flush request
    Property<0X40004400 + 0X18, 4, 1> TXFRQ;                // Transmit data flush request
};


enum class USART2_ISR
{
    PE,                        // Parity error
    FE,                        // Framing error
    NF,                        // Noise detected flag
    ORE,                       // Overrun error
    IDLE,                      // Idle line detected
    RXNE,                      // Read data register not empty
    TC,                        // Transmission complete
    TXE,                       // Transmit data register empty
    LBDF,                      // LIN break detection flag
    CTSIF,                     // CTS interrupt flag
    CTS,                       // CTS flag
    RTOF,                      // Receiver timeout
    EOBF,                      // End of block flag
    ABRE = 14,                 // Auto baud rate error
    ABRF,                      // Auto baud rate flag
    BUSY,                      // Busy flag
    CMF,                       // character match flag
    SBKF,                      // Send break flag
    RWU,                       // Receiver wakeup from Mute mode
    WUF,                       // Wakeup from Stop mode flag
    TEACK,                     // Transmit enable acknowledge flag
    REACK,                     // Receive enable acknowledge flag
};

/*
    Interrupt & status register @ 0X40004400 + 0X1C
*/
struct usart2_isr : public reg32bit<USART2_ISR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X1C, 0, 1> PE;                   // Parity error
    Property<0X40004400 + 0X1C, 1, 1> FE;                   // Framing error
    Property<0X40004400 + 0X1C, 2, 1> NF;                   // Noise detected flag
    Property<0X40004400 + 0X1C, 3, 1> ORE;                  // Overrun error
    Property<0X40004400 + 0X1C, 4, 1> IDLE;                 // Idle line detected
    Property<0X40004400 + 0X1C, 5, 1> RXNE;                 // Read data register not empty
    Property<0X40004400 + 0X1C, 6, 1> TC;                   // Transmission complete
    Property<0X40004400 + 0X1C, 7, 1> TXE;                  // Transmit data register empty
    Property<0X40004400 + 0X1C, 8, 1> LBDF;                 // LIN break detection flag
    Property<0X40004400 + 0X1C, 9, 1> CTSIF;                // CTS interrupt flag
    Property<0X40004400 + 0X1C, 10, 1> CTS;                 // CTS flag
    Property<0X40004400 + 0X1C, 11, 1> RTOF;                // Receiver timeout
    Property<0X40004400 + 0X1C, 12, 1> EOBF;                // End of block flag
    Property<0X40004400 + 0X1C, 14, 1> ABRE;                // Auto baud rate error
    Property<0X40004400 + 0X1C, 15, 1> ABRF;                // Auto baud rate flag
    Property<0X40004400 + 0X1C, 16, 1> BUSY;                // Busy flag
    Property<0X40004400 + 0X1C, 17, 1> CMF;                 // character match flag
    Property<0X40004400 + 0X1C, 18, 1> SBKF;                // Send break flag
    Property<0X40004400 + 0X1C, 19, 1> RWU;                 // Receiver wakeup from Mute mode
    Property<0X40004400 + 0X1C, 20, 1> WUF;                 // Wakeup from Stop mode flag
    Property<0X40004400 + 0X1C, 21, 1> TEACK;               // Transmit enable acknowledge flag
    Property<0X40004400 + 0X1C, 22, 1> REACK;               // Receive enable acknowledge flag
};


enum class USART2_ICR
{
    PECF,                      // Parity error clear flag
    FECF,                      // Framing error clear flag
    NCF,                       // Noise detected clear flag
    ORECF,                     // Overrun error clear flag
    IDLECF,                    // Idle line detected clear flag
    TCCF = 6,                  // Transmission complete clear flag
    LBDCF = 8,                 // LIN break detection clear flag
    CTSCF,                     // CTS clear flag
    RTOCF = 11,                // Receiver timeout clear flag
    EOBCF,                     // End of timeout clear flag
    CMCF = 17,                 // Character match clear flag
    WUCF = 20,                 // Wakeup from Stop mode clear flag
};

/*
    Interrupt flag clear register @ 0X40004400 + 0X20
*/
struct usart2_icr : public reg32bit<USART2_ICR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40004400 + 0X20, 0, 1> PECF;                 // Parity error clear flag
    Property<0X40004400 + 0X20, 1, 1> FECF;                 // Framing error clear flag
    Property<0X40004400 + 0X20, 2, 1> NCF;                  // Noise detected clear flag
    Property<0X40004400 + 0X20, 3, 1> ORECF;                // Overrun error clear flag
    Property<0X40004400 + 0X20, 4, 1> IDLECF;               // Idle line detected clear flag
    Property<0X40004400 + 0X20, 6, 1> TCCF;                 // Transmission complete clear flag
    Property<0X40004400 + 0X20, 8, 1> LBDCF;                // LIN break detection clear flag
    Property<0X40004400 + 0X20, 9, 1> CTSCF;                // CTS clear flag
    Property<0X40004400 + 0X20, 11, 1> RTOCF;               // Receiver timeout clear flag
    Property<0X40004400 + 0X20, 12, 1> EOBCF;               // End of timeout clear flag
    Property<0X40004400 + 0X20, 17, 1> CMCF;                // Character match clear flag
    Property<0X40004400 + 0X20, 20, 1> WUCF;                // Wakeup from Stop mode clear flag
};


/*
    Universal synchronous asynchronous receiver transmitter @ 0X40004400
*/
struct USART2
{
    usart2_cr1 CR1;            // Control register 1
    usart2_cr2 CR2;            // Control register 2
    usart2_cr3 CR3;            // Control register 3
    usart2_brr BRR;            // Baud rate register
    usart2_gtpr GTPR;          // Guard time and prescaler register
    usart2_rtor RTOR;          // Receiver timeout register
    usart2_rqr RQR;            // Request register
    usart2_isr ISR;            // Interrupt & status register
    usart2_icr ICR;            // Interrupt flag clear register
    regrw RDR;                 // Receive data register
    regrw TDR;                 // Transmit data register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40004400);}
};


enum class WWDG_CR
{
    T,                         // 7-bit counter
    WDGA = 7,                  // Activation bit
};

/*
    Control register @ 0X40002C00 + 0X00
*/
struct wwdg_cr : public reg32bit<WWDG_CR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002C00 + 0X00, 0, 7> T;                    // 7-bit counter
    Property<0X40002C00 + 0X00, 7, 1> WDGA;                 // Activation bit
};


enum class WWDG_CFR
{
    W,                         // 7-bit window value
    WDGTB = 7,                 // Timer base
    EWI = 9,                   // Early wakeup interrupt
};

/*
    Configuration register @ 0X40002C00 + 0X04
*/
struct wwdg_cfr : public reg32bit<WWDG_CFR>
{
    using reg32bit::operator =;
    using reg32bit::operator |=;

    Property<0X40002C00 + 0X04, 0, 7> W;                    // 7-bit window value
    Property<0X40002C00 + 0X04, 7, 2> WDGTB;                // Timer base
    Property<0X40002C00 + 0X04, 9, 1> EWI;                  // Early wakeup interrupt
};


/*
    Window watchdog @ 0X40002C00
*/
struct WWDG
{
    wwdg_cr CR;                // Control register
    wwdg_cfr CFR;              // Configuration register
    regrw SR;                  // Status register

    void *operator new(size_t) {return reinterpret_cast<void *>(0X40002C00);}
};

